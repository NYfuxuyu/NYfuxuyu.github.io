<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java基础 | 知识星球</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/avatar.jpg">
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.a26fb221.css" as="style"><link rel="preload" href="/assets/js/app.3bc42cf8.js" as="script"><link rel="preload" href="/assets/js/3.0146fe10.js" as="script"><link rel="preload" href="/assets/js/1.760be874.js" as="script"><link rel="preload" href="/assets/js/16.62996748.js" as="script"><link rel="prefetch" href="/assets/js/10.2fa36d92.js"><link rel="prefetch" href="/assets/js/11.d5259c34.js"><link rel="prefetch" href="/assets/js/12.3b11beda.js"><link rel="prefetch" href="/assets/js/13.8e606e78.js"><link rel="prefetch" href="/assets/js/14.7e273577.js"><link rel="prefetch" href="/assets/js/15.9080a48f.js"><link rel="prefetch" href="/assets/js/17.afa987aa.js"><link rel="prefetch" href="/assets/js/18.04a1e384.js"><link rel="prefetch" href="/assets/js/19.51469f95.js"><link rel="prefetch" href="/assets/js/20.180dc3cd.js"><link rel="prefetch" href="/assets/js/21.32d43e7f.js"><link rel="prefetch" href="/assets/js/22.f1326aa2.js"><link rel="prefetch" href="/assets/js/23.35607ff8.js"><link rel="prefetch" href="/assets/js/24.60cebcf3.js"><link rel="prefetch" href="/assets/js/25.4b8dd78e.js"><link rel="prefetch" href="/assets/js/26.13c2f0ff.js"><link rel="prefetch" href="/assets/js/4.a5370f7a.js"><link rel="prefetch" href="/assets/js/5.716a9c5a.js"><link rel="prefetch" href="/assets/js/6.048f2fb7.js"><link rel="prefetch" href="/assets/js/7.c3f4f112.js"><link rel="prefetch" href="/assets/js/8.64d54cc1.js"><link rel="prefetch" href="/assets/js/9.4411a8b9.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a26fb221.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-2d5f533b><div data-v-2d5f533b><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-2d5f533b data-v-2d5f533b><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-2d5f533b data-v-2d5f533b><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>知识星球</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>知识星球</span>
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-2d5f533b><header class="navbar" data-v-2d5f533b><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/avatar.jpg" alt="知识星球" class="logo"> <span class="site-name">知识星球</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      计算机基础
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/network/" class="nav-link"><i class="iconfont reco-network"></i>
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/operationsystem/" class="nav-link"><i class="iconfont reco-system"></i>
  操作系统
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-sql"></i>
      数据库
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mysql/" class="nav-link"><i class="iconfont undefined"></i>
  Mysql
</a></li><li class="dropdown-item"><!----> <a href="/sql/Redis.html" class="nav-link"><i class="iconfont undefined"></i>
  Redis
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-java"></i>
      Java基础
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/javase/" class="nav-link router-link-exact-active router-link-active"><i class="iconfont undefined"></i>
  JavaSE
</a></li><li class="dropdown-item"><!----> <a href="/collection/" class="nav-link"><i class="iconfont undefined"></i>
  Java集合
</a></li><li class="dropdown-item"><!----> <a href="/juc/" class="nav-link"><i class="iconfont undefined"></i>
  Java并发
</a></li><li class="dropdown-item"><!----> <a href="/jvm/" class="nav-link"><i class="iconfont undefined"></i>
  JVM
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      框架
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mybatis/" class="nav-link"><i class="iconfont undefined"></i>
  Mybaits
</a></li><li class="dropdown-item"><!----> <a href="/spring/" class="nav-link"><i class="iconfont undefined"></i>
  Spring
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      扩展
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/data/" class="nav-link"><i class="iconfont undefined"></i>
  海量数据
</a></li><li class="dropdown-item"><!----> <a href="/area/" class="nav-link"><i class="iconfont undefined"></i>
  系统设计题
</a></li><li class="dropdown-item"><!----> <a href="/suanfa/" class="nav-link"><i class="iconfont undefined"></i>
  算法
</a></li><li class="dropdown-item"><!----> <a href="/iq/" class="nav-link"><i class="iconfont undefined"></i>
  智力题
</a></li><li class="dropdown-item"><!----> <a href="/shejimoshi/" class="nav-link"><i class="iconfont undefined"></i>
  设计模式
</a></li></ul></div></div><div class="nav-item"><a href="http://blog.fuxuyu.top/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont undefined"></i>
  个人博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://gitee.com/fuxuyu" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-mayun"></i>
  码云
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/NYfuxuyu" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-2d5f533b></div> <aside class="sidebar" data-v-2d5f533b><div class="personal-info-wrapper" data-v-ca798c94 data-v-2d5f533b><!----> <h3 class="name" data-v-ca798c94>
    知识星球
  </h3> <div class="num" data-v-ca798c94><div data-v-ca798c94><h3 data-v-ca798c94>16</h3> <h6 data-v-ca798c94>Article</h6></div> <div data-v-ca798c94><h3 data-v-ca798c94>14</h3> <h6 data-v-ca798c94>Tag</h6></div></div> <hr data-v-ca798c94></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      计算机基础
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/network/" class="nav-link"><i class="iconfont reco-network"></i>
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/operationsystem/" class="nav-link"><i class="iconfont reco-system"></i>
  操作系统
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-sql"></i>
      数据库
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mysql/" class="nav-link"><i class="iconfont undefined"></i>
  Mysql
</a></li><li class="dropdown-item"><!----> <a href="/sql/Redis.html" class="nav-link"><i class="iconfont undefined"></i>
  Redis
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-java"></i>
      Java基础
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/javase/" class="nav-link router-link-exact-active router-link-active"><i class="iconfont undefined"></i>
  JavaSE
</a></li><li class="dropdown-item"><!----> <a href="/collection/" class="nav-link"><i class="iconfont undefined"></i>
  Java集合
</a></li><li class="dropdown-item"><!----> <a href="/juc/" class="nav-link"><i class="iconfont undefined"></i>
  Java并发
</a></li><li class="dropdown-item"><!----> <a href="/jvm/" class="nav-link"><i class="iconfont undefined"></i>
  JVM
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      框架
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mybatis/" class="nav-link"><i class="iconfont undefined"></i>
  Mybaits
</a></li><li class="dropdown-item"><!----> <a href="/spring/" class="nav-link"><i class="iconfont undefined"></i>
  Spring
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      扩展
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/data/" class="nav-link"><i class="iconfont undefined"></i>
  海量数据
</a></li><li class="dropdown-item"><!----> <a href="/area/" class="nav-link"><i class="iconfont undefined"></i>
  系统设计题
</a></li><li class="dropdown-item"><!----> <a href="/suanfa/" class="nav-link"><i class="iconfont undefined"></i>
  算法
</a></li><li class="dropdown-item"><!----> <a href="/iq/" class="nav-link"><i class="iconfont undefined"></i>
  智力题
</a></li><li class="dropdown-item"><!----> <a href="/shejimoshi/" class="nav-link"><i class="iconfont undefined"></i>
  设计模式
</a></li></ul></div></div><div class="nav-item"><a href="http://blog.fuxuyu.top/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont undefined"></i>
  个人博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://gitee.com/fuxuyu" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-mayun"></i>
  码云
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/NYfuxuyu" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-2d5f533b><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>Java基础</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>知识星球</span>
            
          <!---->
          2022
        </a></span></div></div> <div data-v-2d5f533b><main class="page"><div class="page-title" style="display:none;"><h1 class="title">Java基础</h1> <div data-v-3b7f5bdf><i class="iconfont reco-account" data-v-3b7f5bdf><span data-v-3b7f5bdf>仪轩</span></i> <i class="iconfont reco-date" data-v-3b7f5bdf><span data-v-3b7f5bdf>2020-08-16</span></i> <!----> <i class="iconfont reco-tag tags" data-v-3b7f5bdf><span class="tag-item" data-v-3b7f5bdf>JavaSE</span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><blockquote><p>Java基础</p></blockquote> <h2 id="jvm、jre及jdk的关系"><a href="#jvm、jre及jdk的关系" class="header-anchor">#</a> JVM、JRE及JDK的关系</h2> <p>JDK（Java Development Kit）是针对Java开发员的产品，是整个Java的核心，包括了Java运行环境 JRE、Java工具和Java基础类库。</p> <p>JRE（Java Runtime Environment）是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核 心类库。</p> <p>JVM（Java Virtual Machine）是整个java实现跨平台的最核心的部分，能够运 行以Java语言写作的软件程序。</p> <p><strong>简单来说就是JDK是Java的开发工具，JRE是Java程序运行所需的环境，JVM是Java虚拟机．它们之间的关系是JDK包含JRE和JVM，JRE包含JVM．</strong></p> <h2 id="java和c-的区别"><a href="#java和c-的区别" class="header-anchor">#</a> JAVA和C++的区别</h2> <h3 id="java的优点："><a href="#java的优点：" class="header-anchor">#</a> <strong>Java的优点：</strong></h3> <p>1.Java为纯面向对象的语言，能够直接反应现实生活中的对象，容易理解，编程更容易。</p> <p>2.跨平台，java是解释性语言，编译器会把java代码变成中间代码，然后在JVM上解释执行，由于中间代码和平台无关因此，java语言可以跨平台执行，具有很好的移植性。</p> <p>3.Java提供了很多内置的类库，简化了开发人员的程序设计工作，缩短了项目的开发时间。例如，Java语言提供了对多线程的支持，提供了对网络通信的支持，最重要的是提供了垃圾回收器，这使得开发人员从对内存的管理中解脱出来。</p> <h3 id="c-有而java没有的特性"><a href="#c-有而java没有的特性" class="header-anchor">#</a> <strong>C++有而Java没有的特性</strong></h3> <ul><li>C++支持多重继承，Java语言不支持多重继承。但是Java引入了接口的概念，可以同时实现多个接口。由于接口也具有多态特性，因此在Java语言中可以通过实现多个接口来实现与C++语言中多重继承类似的目的。</li> <li>C++语言支持运算符重载，而Java语言不支持运算符重载</li> <li>C++支持函数的默认参数，java不支持</li> <li>C++支持自动强制类型转换，这会导致线程的安全；Java不支持自动的转化，需要开发人员显示的转化</li></ul> <h3 id="java有c-没有的特性"><a href="#java有c-没有的特性" class="header-anchor">#</a> <strong>Java有C++没有的特性</strong></h3> <ul><li><p>Java语言提供了垃圾回收器来实现垃圾的自动回收，不需要程序显式地管理内存的分配。在C++语言中，需要开发人员去管理对内存的分配（包括申请与释放），而在C++语言中，通常都会把释放资源的代码放到析构函数中。Java语言引入了一个finalize()方法，当垃圾回收器将要释放无用对象的内存时，会首先调用该对象的finalize()方法，因此，开发人员不需要关心也不需要知道对象所占的内存空间何时会被释放。</p></li> <li><p>Java为半解释性语言，其运行过程为：程序源代码经过Java编译器编译成字节码，然后由JVM解释执行。而C/C++为编译型语言，源代码经过编译和链接后生成可执行的二进制代码。因此，Java的执行速度比C/C++慢，但是Java能够跨平台执行，而C/C++不能。</p></li> <li><p>java中没有指针，有效防止了C++中操纵地址带来的不安全</p></li></ul> <h2 id="java的基本数据类型"><a href="#java的基本数据类型" class="header-anchor">#</a> Java的基本数据类型</h2> <p><img src="https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209051629416.png" alt="image-20220417144514270"></p> <blockquote><p>强调：String不是基本数据类型</p></blockquote> <h2 id="隐式-自动-类型转换和显示-强制-类型转换"><a href="#隐式-自动-类型转换和显示-强制-类型转换" class="header-anchor">#</a> 隐式(自动)类型转换和显示(强制)类型转换</h2> <ul><li><p>隐式(自动)类型转换：从存储范围小的类型到存储范围大的类型。</p> <p><code>byte</code> → <code>short(char)</code> → <code>int</code> → <code>long</code>→ <code>float</code> → <code>double</code></p></li> <li><p>显示(强制)类型转换：从存储范围大的类型到存储范围小的类型。</p></li></ul> <p><code>double</code>→ <code>float</code>→ <code>long</code>→ <code>int</code> → <code>short(char)</code>→ <code>byte</code> 。该类类型转换很可能存在精度的损失。</p> <p>看一个经典的代码</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">short</span> s <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
s <span class="token operator">=</span> s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre></div><p>这是会报错的，因为1是 <code>int</code> 型， s+1 会自动转换为<code>int</code> 型，将 <code>int</code>型直接赋值给 <code>short</code>型会报错。 做一下修改即可避免报错</p> <p>正确的应该修改为</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">short</span> s <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>或这样写，因为 s += 1 会自动进行强制类型转换</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">short</span> s <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
s <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="header-anchor">#</a> 自动装箱与拆箱</h2> <ul><li>装箱：将基本类型用包装器类型包装起来</li> <li>拆箱：将包装器类型转换为基本类型</li></ul> <blockquote><p>下面这段代码的输出结果是什么？</p></blockquote> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        
            <span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
            <span class="token class-name">Integer</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
            <span class="token class-name">Integer</span> c <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>
            <span class="token class-name">Integer</span> d <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token operator">==</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token operator">==</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token boolean">true</span>
<span class="token boolean">false</span>
</code></pre></div><p>很多人看到这个结果会很疑惑，为什么会是一个<code>true</code>一个 <code>flase</code>．其实从源码中可以很容易找到 原因．首先找到<code>Integer</code>方法中的 <code>valueOf</code>方法</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre></div><p>可以看到当不满足 if 语句中的条件，就会重新创建一个对象返回，那结果必然不相等。继续打开 <code>IntegerCache</code>可以看到</p> <div class="language-java extra-class"><pre class="language-java"><code>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IntegerCache</span> <span class="token punctuation">{</span>
          <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>
        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>
          <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Integer</span> cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  
          <span class="token keyword">static</span> <span class="token punctuation">{</span>
              <span class="token comment">// high value may be configured by property</span>
              <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>
              <span class="token class-name">String</span> integerCacheHighPropValue <span class="token operator">=</span>
                 
sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>VM<span class="token punctuation">.</span><span class="token function">getSavedProperty</span><span class="token punctuation">(</span><span class="token string">&quot;java.lang.Integer.IntegerCache.high&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                  <span class="token keyword">try</span> <span class="token punctuation">{</span>
                      <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
                      i <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                      <span class="token comment">// Maximum array size is Integer.MAX_VALUE</span>
h <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">-</span>low<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                 <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span> <span class="token class-name">NumberFormatException</span> nfe<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                      <span class="token comment">// If the property cannot be parsed into an int, </span>
ignore it<span class="token punctuation">.</span>
                 <span class="token punctuation">}</span>
             <span class="token punctuation">}</span>
              high <span class="token operator">=</span> h<span class="token punctuation">;</span>
  
              cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  			  <span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span>
              <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
                  cache<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
              <span class="token comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span>
              <span class="token keyword">assert</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high <span class="token operator">&gt;=</span> <span class="token number">127</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
  
          <span class="token keyword">private</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
</code></pre></div><p>上面这段代码的大致意思就是：通过 <code>valueOf</code> 方法创建<code>Integer</code> 对象的时候，如果数值在[-128,127] 之间，便返回指向<code>IntegerCache.cache</code>中已经存在的对象的引用；否则创建一个新的<code>Integer 对象</code>。所以上面代码中 a 与 b 相等， c 与 d 不相等。</p> <ul><li>在看下面的代码会输出什么</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Double</span> a <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>
            <span class="token class-name">Double</span> b <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>
            <span class="token class-name">Double</span> c <span class="token operator">=</span> <span class="token number">2.0</span><span class="token punctuation">;</span>
            <span class="token class-name">Double</span> d <span class="token operator">=</span> <span class="token number">2.0</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token operator">==</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token operator">==</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code>flase 
flase
</code></pre></div><p>采用同样的方法，可以看到 <code>Double</code> 的<code>valueOf</code>方法，每次返回都是重新 new 一个新的对象，所 以上面代码中的结果都不想等。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Double</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">double</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>最后再看这段代码的输出结果</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Boolean</span> a <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token class-name">Boolean</span> b <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token class-name">Boolean</span> c <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token class-name">Boolean</span> d <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token operator">==</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token operator">==</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token boolean">true</span>
<span class="token boolean">true</span>
</code></pre></div><p>继续分析<code>valueOf</code>方法</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Boolean</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>b <span class="token operator">?</span> TRUE <span class="token operator">:</span> FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre></div><p>再看看<code>TRUE</code> 和<code>FALSE</code> 是个什么东西，是两个静态成员属性。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Boolean</span> TRUE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Boolean</span> FALSE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>说下结论 ： <code>Integer</code> 、<code>Short</code> 、 <code>Byte</code>、 <code>Character</code> 、<code>Long</code>这几个类的 <code>valueOf</code> 方法的实现是类似的。 <code>Double</code>、<code>Float</code> 的 <code>valueOf</code> 方法的实现是类似的。然后是<code>Boolean</code> 的<code>valueOf</code>方法是单独一组的。</p> <ul><li><code>Integer i = new Integer(xxx)</code>和<code>Integer i =xxx</code> 的区别</li></ul> <p>这两者的区别主要是第一种会触发自动装箱，第二者不会</p> <p>最后看看下面这段程序的输出结果</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token class-name">Integer</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token class-name">Integer</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
        <span class="token class-name">Long</span> g <span class="token operator">=</span> <span class="token number">3L</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> int1 <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> int2 <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
        <span class="token class-name">Integer</span> integer1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Integer</span> integer2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Integer</span> integer3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;c==(a+b) -&gt;&quot;</span><span class="token operator">+</span> <span class="token punctuation">(</span>c<span class="token operator">==</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;g==(a+b) -&gt;&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>g<span class="token operator">==</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">&quot;c.equals(a+b) -&gt;&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">&quot;g.equals(a+b) -&gt;&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;int1 == int2 -&gt; &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>int1 <span class="token operator">==</span> int2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;int1 == integer1 -&gt; &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>int1 <span class="token operator">==</span> integer1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;integer1 == integer2 -&gt; &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>integer1 <span class="token operator">==</span>integer2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;integer3 == a1 -&gt; &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>integer3 <span class="token operator">==</span> a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>结果如下：</p> <div class="language-java extra-class"><pre class="language-java"><code>c<span class="token operator">==</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span><span class="token boolean">true</span>
g<span class="token operator">==</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span><span class="token boolean">true</span>
c<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span><span class="token boolean">true</span>
g<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span><span class="token boolean">false</span>
int1 <span class="token operator">==</span> int2 <span class="token operator">-&gt;</span> <span class="token boolean">true</span>
int1 <span class="token operator">==</span> integer1 <span class="token operator">-&gt;</span> <span class="token boolean">true</span>
integer1 <span class="token operator">==</span> integer2 <span class="token operator">-&gt;</span> <span class="token boolean">false</span>
integer3 <span class="token operator">==</span> a1 <span class="token operator">-&gt;</span> <span class="token boolean">false</span>
</code></pre></div><p>下面来简单解释一下：</p> <ol><li>当 &quot; == &quot;运算符的两个操作数都是包装器类型的引用，则是比较指向的是否是同一个对象，而如果 其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。所 以 <code>c == a+b</code> ， <code>g == a+b</code>为<code>true</code> 。</li> <li>而对于<code>equals</code>方法会先触发自动拆箱过程，再触发自动装箱过程。也就是说<code>a+b</code>，会先各自调 用 intValue 方法，得到了加法运算后的数值之后，便调用 <code>Integer.valueOf</code>方法，再进行 equals 比较。所以 <code>c.equals(a+b)</code> 为<code>true</code> 。而对于<code>g.equals(a+b)</code>， a+b 会先拆箱进行相加运算，在装箱进行 <code>equals</code>比较，但是装箱后为<code>Integer</code> ， g 为 <code>Long</code>，所以 <code>g.equals(a+b)</code>为 <code>false</code>。</li> <li><code>int1 == int2</code>为<code>true</code>无需解释， <code>int1 == integer1</code> ，在进行比较时，<code>integer1</code>会先进行 一个拆箱操作变成 int 型在进行比较，所以 <code>int1 == integer1</code>为 true</li> <li><code>integer1 == integer2 -&gt; false</code>。<code>integer1</code>和<code>integer2</code>都是通过 new 关键字创建的，可以 看成两个对象，所以 <code>integer1 == integer2</code> 为 <code>false</code>。 <code>integer3 == a1 -&gt; false</code> , <code>integer3</code>是一个对象类型，而 <code>a1</code>是一个常量它们存放内存的位置不一样，所以<code>integer3 == a1</code>为 false ，具体原因可学习下java的内存模型。</li></ol> <h2 id="string类型"><a href="#string类型" class="header-anchor">#</a> String类型</h2> <p><strong>再次强调String不是基本数据类型</strong></p> <h4 id="string的不可变性"><a href="#string的不可变性" class="header-anchor">#</a> String的不可变性</h4> <p>在 Java8中， <code>String</code>内部使用<code>char</code>数组存储数据。并且被声明为<code>final</code>，因此它不可被继承。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token keyword">implements</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span><span class="token class-name">Serializable</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">{</span> 
 <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为什么 <code>String</code>要设计成不可变的呢（不可变性的好处）:</p> <ol><li><p>可以缓存 hash 值（）</p> <p>因为 <code>String</code>的 <code>hash</code> 值经常被使用，例如 <code>String</code>用做 <code>HashMap</code>的<code>key</code> 。不可变的特性可以使得 hash 值也不可变， 因此只需要进行一次计算。</p></li> <li><p>常量池的优化</p> <p><code>String</code>对象被创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</p></li> <li><p>线程安全</p> <p><code>String</code> 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p></li></ol> <h4 id="什么是字符串常量池"><a href="#什么是字符串常量池" class="header-anchor">#</a> 什么是字符串常量池?</h4> <p>​	字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间 存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返 回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</p> <h4 id="string-类的常用方法都有那些？"><a href="#string-类的常用方法都有那些？" class="header-anchor">#</a> String 类的常用方法都有那些？</h4> <blockquote><p>面试一般不会问，主要是算法题会用到</p></blockquote> <ul><li><code>length()</code> ：返回字符串长度 charAt() ：返回指定索引处的字符</li> <li><code>substring()</code> ：截取字符串</li> <li><code>trim()</code>：去除字符串两端空白</li> <li><code>split()</code>：分割字符串，返回一个分割后的字符串数组。</li> <li><code>replace()</code> ：字符串替换。</li> <li><code>indexOf()</code> ：返回指定字符的索引。</li> <li><code>toLowerCase()</code> ：将字符串转成小写字母。</li> <li><code>toUpperCase()</code>：将字符串转成大写字符。</li></ul> <h4 id="string和stringbuffer、stringbuilder的区别是什么？"><a href="#string和stringbuffer、stringbuilder的区别是什么？" class="header-anchor">#</a> String和StringBuffer、StringBuilder的区别是什么？</h4> <p>1.可变性</p> <p>​	<code>String</code>不可变， <code>StringBuilder</code>和 <code>StringBuffer</code> 是可变的</p> <p>2.线程安全性</p> <p>​	<code>String</code> 由于是不可变的，所以线程安全。 <code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加 了同步锁，所以是线程安全的。 <code>StringBuilder</code>并没有对方法进行加同步锁，所以是非线程安全的。</p> <p>3.性能</p> <p>​	<code>StringBuilder</code>&gt; <code>StringBuffer</code> &gt; <code>String</code></p> <p>具体总结如下：</p> <table><thead><tr><th style="text-align:center;"></th> <th style="text-align:center;">是否可变</th> <th style="text-align:center;">是否安全</th> <th style="text-align:center;">性能</th></tr></thead> <tbody><tr><td style="text-align:center;">String</td> <td style="text-align:center;">不可变</td> <td style="text-align:center;">安全</td> <td style="text-align:center;">低</td></tr> <tr><td style="text-align:center;">StringBuilder</td> <td style="text-align:center;">可变</td> <td style="text-align:center;">不安全</td> <td style="text-align:center;">高</td></tr> <tr><td style="text-align:center;">StringBuffer</td> <td style="text-align:center;">可变</td> <td style="text-align:center;">安全</td> <td style="text-align:center;">较高</td></tr></tbody></table> <h2 id="访问修饰符"><a href="#访问修饰符" class="header-anchor">#</a> 访问修饰符</h2> <p>在Java编程语言中有四种权限访问控制符，这四种访问权限的控制符能够控制类中成员的可见性。其 中类有两种 <code>public</code> 、<code>default</code>。而方法和变量有 4 种：<code>public</code> 、<code>default</code> 、 <code>protected</code> 、 <code>private</code>。</p> <ul><li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法</li> <li><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</li> <li><strong>default</strong> : 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li> <li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</li></ul> <table><thead><tr><th style="text-align:center;">修饰符</th> <th style="text-align:center;">当前类</th> <th style="text-align:center;">同包内</th> <th style="text-align:center;">子类（同包）</th> <th style="text-align:center;">其他包</th></tr></thead> <tbody><tr><td style="text-align:center;">public</td> <td style="text-align:center;">Y</td> <td style="text-align:center;">Y</td> <td style="text-align:center;">Y</td> <td style="text-align:center;">Y</td></tr> <tr><td style="text-align:center;">protected</td> <td style="text-align:center;">Y</td> <td style="text-align:center;">Y</td> <td style="text-align:center;">Y</td> <td style="text-align:center;">N</td></tr> <tr><td style="text-align:center;">default</td> <td style="text-align:center;">Y</td> <td style="text-align:center;">Y</td> <td style="text-align:center;">Y</td> <td style="text-align:center;">N</td></tr> <tr><td style="text-align:center;">private</td> <td style="text-align:center;">Y</td> <td style="text-align:center;">N</td> <td style="text-align:center;">N</td> <td style="text-align:center;">N</td></tr></tbody></table> <h2 id="关键字"><a href="#关键字" class="header-anchor">#</a> 关键字</h2> <h3 id="static关键字"><a href="#static关键字" class="header-anchor">#</a> static关键字</h3> <p><code>static</code> 关键字的主要用途就是方便在没有创建对象时调用方法和变量和优化程序性能</p> <p><strong>1.static变量（静态变量）</strong></p> <p>​	用 <code>static</code>修饰的变量被称为静态变量，也被称为类变量，可以直接通过类名来访问它。静态变量被所有的对象共享，在内存中只有一个副本，仅当在类初次加载时会被初始化，而非静态变量在创建对象 的时候被初始化，并且存在多个副本，各个对象拥有的副本互不影响。</p> <p><strong>2.static方法(静态方法)</strong></p> <p>​	<code>static</code>方法不依赖于任何对象就可以进行访问，在 static 方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用，但是在非静态成员方 法中是可以访问静态成员方法/变量的。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">&quot;s1&quot;</span><span class="token punctuation">;</span><span class="token comment">//静态变量</span>
    <span class="token class-name">String</span> s2  <span class="token operator">=</span> <span class="token string">&quot;s2&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此处报错，静态方法不能调用非静态变量</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>3.static代码块（静态代码块）</strong></p> <p>​	静态代码块的主要用途是可以用来优化程序的性能，因为它只会在类加载时加载一次，很多时候会将 一些只需要进行一次的初始化操作都放在<code>static</code>代码块中进行。如果程序中有多个 <code>static</code> 块，在类初 次被加载的时候，会按照<code>static</code>块的顺序来执行每个<code>static</code>块。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello,word&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Main</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>4.初始化顺序</strong></p> <p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它 们在代码中的顺序。如果存在继承关系的话，初始化顺序为:</p> <p><strong>父类中的静态变量和静态代码块——子类中 的静态变量和静态代码块——父类中的实例变量和普通代码块——父类的构造函数——子类的实例变量 和普通代码块——子类的构造函数</strong></p> <p><strong>在⼀个静态方法内调用⼀个非静态成员为什么是非法的</strong></p> <p>静态方法是属于类层面的，它随着类的加载而加载。JVM在加载类时，就会为静态方法分配内存，可以通过'类名.方法名'来进行调用。静态方法在任意对象实例化之前就已经存在。</p> <p>非静态成员(方法或者变量)是属于实例对象的，而实例对象则是在类加载完成之后再创建的。当实例化一个对象时，JVM会为其在堆上分配内存，然后通过this指针指向该实例对象。非静态成员只有在对象实例化之后才会分配内存，然后通过实例对象引用来进行访问。对象都没有存在，非静态成员当然也不存在，只依赖于类而不依赖于实例对象的静态方法自然不能调用一个不存在的方法，当然也根本不知道会调用哪个实例对象的方法</p> <h3 id="final-关键字"><a href="#final-关键字" class="header-anchor">#</a> final 关键字</h3> <p><code>final</code>关键字主要用于修饰类，变量，方法。</p> <ol><li>类：被<code>final</code>修饰的类不可以被继承 ，即不可以拥有自己的子类</li> <li>方法：被<code>final</code> 修饰的方法不可以被重写</li> <li>变量：被<code>final</code>修饰的变量是基本类型，变量的数值不能改变；被修饰的变量是引用类型，变量便不能在引用其他对象，但是变量所引用的对象本身是可以改变的。</li> <li>final修饰的变量，无论是类属性，对象还是方法都需要进行<strong>初始化</strong>的操作</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//报错</span>
        <span class="token keyword">final</span> <span class="token class-name">Main</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        m<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//不报错,可以改变引用类型变量所指向的对象</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
</code></pre></div><p><code>final</code> <code>finally</code> <code>finalize</code>区别</p> <ul><li><code>final</code> 主要用于修饰类，变量，方法</li> <li><code>finally</code>一般作用在<code>try-catch</code>代码块中，在处理异常的时候，通常我们将一定要执行的代码方法 finally 代码块 中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li> <li><code>finalize</code> 是一个属于 <code>Object</code>类的一个方法，该方法一般由垃圾回收器来调用，当我们调用 System.gc() 方法的时候，由垃圾回收器调用<code>finalize()</code>，回收垃圾，但Java语言规范并不保证 <code>finalize</code> 方法会被及时地执行、而且根本不会保证它们会被执行。</li></ul> <h3 id="this关键字"><a href="#this关键字" class="header-anchor">#</a> this关键字</h3> <ol><li><code>this</code> 关键字可用来引用当前类的实例变量。主要用于形参与成员名字重名，用 this 来区分。</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li><code>this</code>关键字可用于调用当前类方法。</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello,word&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//this可省略</span>
   <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Main</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        m<span class="token punctuation">.</span><span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="3"><li><code>this()</code> 可以用来调用当前类的构造函数。(注意： <code>this()</code>一定要放在构造函数的第一行，否则编译 不通过)</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="4"><li><code>this</code> 关键字可作为调用方法中的参数传递。</li> <li><code>this</code> 关键字可作为参数在构造函数调用中传递。</li> <li><code>this</code> 关键字可用于从方法返回当前类的实例。</li></ol> <h3 id="super关键字"><a href="#super关键字" class="header-anchor">#</a> super关键字</h3> <ol><li><code>super</code> 可以用来引用直接父类的实例变量。和 this 类似，主要用于区分父类和子类中相同的字段</li> <li><code>super</code> 可以用来调用直接父类构造函数。(注意： <code>super()</code><strong>一定要放在构造函数的第一行</strong>，否则编译 不通过)</li> <li><code>super</code> 可以用来调用直接父类方法。</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Child</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">&quot;Father&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;Child&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        child<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Father</span><span class="token punctuation">{</span>
<span class="token keyword">protected</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">Say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello,child&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token class-name">String</span> name1<span class="token punctuation">,</span> <span class="token class-name">String</span> name2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name1<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//调用直接父类构造函数</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name2<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">super</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//引用直接父类的实例变量</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token class-name">Say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//调用直接父类方法</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h5 id="this与super的区别"><a href="#this与super的区别" class="header-anchor">#</a> this与super的区别</h5> <ul><li>相同点：
<ol><li><code>super()</code> 和<code>this()</code> 都必须在构造函数的第一行进行调用，否则就是错误的</li> <li><code>this()</code>和 <code>super()</code>都指的是对象，所以，均不可以在<code>static</code>环境中使用。</li></ol></li> <li>不同点：
<ol><li><code>super()</code>主要是对父类构造函数的调用， <code>this()</code>是对重载构造函数的调用</li> <li><code>super()</code>主要是在继承了父类的子类的构造函数中使用，是在不同类中的使用； <code>this()</code>主要 是在同一类的不同构造函数中的使用</li></ol></li></ul> <h3 id="instanceof关键字"><a href="#instanceof关键字" class="header-anchor">#</a> instanceof关键字</h3> <p><code>instanceof</code> 是 Java 的一个二元操作符，类似于 ==，&gt;，&lt; 等操作符。</p> <p><code>instanceof</code> 是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 <code>boolean</code> 的数据类型。</p> <p>以下实例创建了 <code>displayObjectClass()</code>方法来演示 Java<code>instanceof</code>关键字用法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">displayObjectClass</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Vector</span><span class="token punctuation">)</span>
     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;对象是 java.util.Vector 类的实例&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">ArrayList</span><span class="token punctuation">)</span>
     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;对象是 java.util.ArrayList 类的实例&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;对象是 &quot;</span> <span class="token operator">+</span> o<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; 类的实例&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="面向对象"><a href="#面向对象" class="header-anchor">#</a> 面向对象</h2> <h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="header-anchor">#</a> 面向对象和面向过程的区别</h3> <p><strong>面向过程</strong>：</p> <ul><li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li> <li>缺点：没有面向对象易维护、易复用、易扩展。</li></ul> <p><strong>面向对象</strong>：</p> <ul><li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</li> <li>缺点：性能比面向过程低。</li></ul> <h3 id="面向对象三大特性-封装、继承、多态"><a href="#面向对象三大特性-封装、继承、多态" class="header-anchor">#</a> 面向对象三大特性(封装、继承、多态)</h3> <ul><li><p>封装</p> <p><strong>封装就是隐藏对象的属性和实现细节，仅对外公开接口</strong>，控制在程序中属性的读和修改的访问级别。</p></li> <li><p>继承</p></li></ul> <p>​		<strong>继承</strong>就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p> <ul><li>多态</li></ul> <p>​		在Java语言中，多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p> <h3 id="多态的表现形式"><a href="#多态的表现形式" class="header-anchor">#</a> 多态的表现形式</h3> <ul><li>重写</li> <li>重载</li> <li>抽象类</li> <li>接口</li></ul> <h3 id="java为什么不支持多继承"><a href="#java为什么不支持多继承" class="header-anchor">#</a> Java为什么不支持多继承</h3> <ul><li>多继承</li></ul> <p>一个类，只有一个父类的情况，我们叫做单继承。而一个类，同时有多个父类的情况，叫做多继承。在Java中，一个类，只能通过extends关键字继承一个类，不允许多继承。但是，多继承在其他的面向对象语言中是有可能支持的。</p> <ul><li>菱形继承</li></ul> <p>假设我们有类B和类C，它们都继承了相同的类A。另外我们还有类D，类D通过多重继承机制继承了类B和类C。</p> <p><img src="https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209051629328.jpeg" alt="img"></p> <p>这时候，因为D同时继承了B和C，并且B和C又同时继承了A，那么，D中就会因为多重继承，继承到两份来自A中的属性和方法。这时候，在使用D的时候，如果想要调用一个定义在A中的方法时，就会出现歧义。因为这样的继承关系的形状类似于菱形，因此这个问题被形象地称为菱形继承问题。</p> <p>而C++为了解决菱形继承问题，又引入了<strong>虚继承</strong>。</p> <p>所以，在 Java 中，不允许“实现多继承”，即一个类不允许继承多个父类。但是 Java 允许“声明多继承”，即一个类可以实现多个接口，一个接口也可以继承多个父接口。由于接口只允许有方法声明而不允许有方法实现（Java 8以前），这就避免了 C++ 中多继承的歧义问题。</p> <p>但是，Java不支持多继承，在Java 8中支持了默认函数（default method ）之后就不那么绝对了。虽然我们还是没办法使用extends同时继承多个类，但是因为有了默认函数，我们有可能通过implements从多个接口中继承到多个默认函数</p> <h3 id="实现多态的三个必要条件："><a href="#实现多态的三个必要条件：" class="header-anchor">#</a> 实现多态的三个必要条件：</h3> <p><strong>继承</strong>：在多态中必须存在有继承关系的子类和父类。</p> <p><strong>重写</strong>：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p> <p><strong>向上转型</strong>：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//向上转型</span>
          person<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Person&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>   <span class="token comment">//继承</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment">//重载</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Student&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="java-创建对象有哪几种方式"><a href="#java-创建对象有哪几种方式" class="header-anchor">#</a> java 创建对象有哪几种方式</h3> <p>java中提供了以下四种创建对象的方式:</p> <ul><li>new创建新对象</li> <li>通过反射机制</li> <li>采用clone机制</li> <li>通过序列化机制</li></ul> <h3 id="面向对象五大基本原则是什么"><a href="#面向对象五大基本原则是什么" class="header-anchor">#</a> 面向对象五大基本原则是什么</h3> <p>五大原则也就是<strong>SOLID原则</strong></p> <p><strong>单一职责原则（Single-Responsibility Principle）</strong></p> <p>其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。</p> <p>单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。 专注，是一个人优良的品质；同样的，单一也是一个类的优良设计。交杂不清的职责将使得代码看起来特别别扭牵一发而动全身，有失美感和必然导致丑陋的系统错误风险。</p> <p><strong>开放封闭原则（Open-Closed principle）</strong></p> <p>其核心思想是：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。</p> <p>开放封闭原则主要体现在两个方面：</p> <p>1、对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</p> <p>2、对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。</p> <p>实现开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。 “需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。</p> <p><strong>里氏替换原则（Liskov-Substitution Principle）</strong></p> <p>其核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。</p> <p>在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。 里氏替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了Liskov替换原则，才能保证继承复用是可靠地。实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。</p> <p>里氏替换原则是关于继承机制的设计原则，违反了Liskov替换原则就必然导致违反开放封闭原则。</p> <p>里氏替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。</p> <p><strong>依赖倒置原则（Dependecy-Inversion Principle）</strong></p> <p>其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。</p> <p>我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。 抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。</p> <p>依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。</p> <p><strong>接口隔离原则（Interface-Segregation Principle）</strong></p> <p>其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。</p> <p>具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。</p> <p>接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。 分离的手段主要有以下两种：</p> <p>1、<strong>委托分离</strong>，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。</p> <p>2、<strong>多重继承分离</strong>，通过接口多继承来实现客户的需求，这种方式是较好的。</p> <h3 id="抽象类和接口的对比"><a href="#抽象类和接口的对比" class="header-anchor">#</a> 抽象类和接口的对比</h3> <p>在Java语言中，<code>abstract class</code>和<code>interface</code> 是支持抽象类定义的两种机制。抽象类：用来捕捉子类的通用特性的。接口：抽象方法的集合。</p> <p><strong>相同点</strong>：</p> <ul><li>接口和抽象类都不能实例化都包含抽象方法，</li> <li>接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法</li></ul> <p><strong>不同点：</strong></p> <table><thead><tr><th style="text-align:center;">参数</th> <th style="text-align:center;">抽象类</th> <th style="text-align:center;">接口</th></tr></thead> <tbody><tr><td style="text-align:center;">实现</td> <td style="text-align:center;">子类使用 extends 关键字来继承抽象类，如果子类不是抽象类，则需要提供抽象类中所有声明的方法的实现。</td> <td style="text-align:center;">子类使用 implements 关键字来实现接口，需要提供接口中所有声明的方法的实现。</td></tr> <tr><td style="text-align:center;">继承</td> <td style="text-align:center;">抽象类可以继承一个类和实现多个接口；子 类只可以继承一个抽象类</td> <td style="text-align:center;">接口只可以继承接口（一个或多个）； 子类可以实现多个接口</td></tr> <tr><td style="text-align:center;">字段声明</td> <td style="text-align:center;">抽象类的字段声明可以是任意的</td> <td style="text-align:center;">接口的字段默认都是 static 和 final 的</td></tr> <tr><td style="text-align:center;">访问修饰符</td> <td style="text-align:center;">可以用 public、protected 和 default 修饰</td> <td style="text-align:center;">默认修饰符是 public，不能使用其它修饰符</td></tr> <tr><td style="text-align:center;">方法</td> <td style="text-align:center;">完全可以包含普通方法</td> <td style="text-align:center;">只能包含抽象方法、静态方法、默认方法和私有方法，不能为普通方法提供方法实现</td></tr> <tr><td style="text-align:center;">变量</td> <td style="text-align:center;">既可以定义普通成员变量，也可以定义静态常量</td> <td style="text-align:center;">只能定义静态常量，不能定义普通成员变量</td></tr> <tr><td style="text-align:center;">构造方法</td> <td style="text-align:center;">抽象类里的构造方法并不是用于创建对象，而是让其子类调用这些构造方法来完成属于抽象类的初始化操作</td> <td style="text-align:center;">没有构造方法</td></tr> <tr><td style="text-align:center;">初始化块</td> <td style="text-align:center;">可以包含初始化块</td> <td style="text-align:center;">不能包含初始化块</td></tr> <tr><td style="text-align:center;">main 方法</td> <td style="text-align:center;">可以有 main 方法，并且能运行</td> <td style="text-align:center;">没有 main 方法</td></tr> <tr><td style="text-align:center;">与普通Java类的区别</td> <td style="text-align:center;">抽象类不能实例化，除此之外和普通 Java 类没有任何区别</td> <td style="text-align:center;">是完全不同的类型</td></tr></tbody></table> <h3 id="抽象类和接口的应用场景"><a href="#抽象类和接口的应用场景" class="header-anchor">#</a> 抽象类和接口的应用场景</h3> <p><strong>抽象类的应用场景：</strong></p> <ol><li>父类只知道其子类应该包含怎样的方法，不能准确知道这些子类如何实现这些方法的情况下，使用抽象类。</li> <li>从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。</li></ol> <p><strong>接口的应用场景：</strong></p> <ol><li>一般情况下，实现类和它的抽象类之前具有 &quot;is-a&quot; 的关系，但是如果我们想达到同样的目的，但是又不存在这种关系时，使用接口。</li> <li>由于 Java 中单继承的特性，导致一个类只能继承一个类，但是可以实现一个或多个接口，此时可以使用接口。</li></ol> <p>什么时候使用抽象类和接口：</p> <ul><li>如果拥有一些方法并且想让它们有默认实现，则使用抽象类。</li> <li>如果想实现多重继承，那么必须使用接口。因为 Java 不支持多继承，子类不能继承多个类，但可以实现多个接口，因此可以使用接口。</li> <li>如果基本功能在不断改变，那么就需要使用抽象类。如果使用接口并不断需要改变基本功能，那么就需要改变所有实现了该接口的类。</li></ul> <h2 id="构造方法有哪些特性"><a href="#构造方法有哪些特性" class="header-anchor">#</a> 构造方法有哪些特性</h2> <ul><li>方法名称和类同名</li> <li>不用定义返回值类型</li> <li>不可以写 retrun 语句</li> <li>构造方法可以被重载</li></ul> <h2 id="内部类"><a href="#内部类" class="header-anchor">#</a> 内部类</h2> <p>内部类包括这四种：<strong>成员内部类</strong>、<strong>局部内部类</strong>、<strong>匿名内部类</strong>和<strong>静态内部类</strong></p> <ul><li>成员内部类</li></ul> <p>1.成员内部类定义为位于另一个类的内部，成员内部类可以无条件访问外部类的所有成员属性和成 员方法（包括<code>private</code>成员和静态成员）。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Outer</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">double</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Outer</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
    <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>     <span class="token comment">//内部类</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>2.当成员内部类拥有和外部类同名的成员变量或者方法时，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：外部类. this .成员变量</p> <p>3.在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问。</p> <p>4.成员内部类是依附外部类而存在的，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Outter</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">double</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Outter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Outter</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>
        <span class="token class-name">Inner</span> inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        inner<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//调用内部类的方法</span>
   <span class="token punctuation">}</span>
    <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>     <span class="token comment">//内部类</span>
        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//访问内部类的b</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Outter</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//访问外部类的b</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Outter</span> outter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token class-name">Outter</span><span class="token punctuation">.</span><span class="token class-name">Inner</span> inner <span class="token operator">=</span> outter<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建内部类的对象</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>局部内部类</li></ul> <p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。<strong>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Outter</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> outter_a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> static_b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> inner_c <span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
        <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>
            <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>outter_a<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>static_b<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>inner_c<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
        <span class="token class-name">Inner</span>  inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建局部内部类</span>
        inner<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> inner_d <span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
        <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>
            <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                 <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>outter_a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//编译错误，定义在静态方法中的局部</span>
类不可以访问外部类的实例变量
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>static_b<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>inner_d<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
        <span class="token class-name">Inner</span>  inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        inner<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>匿名内部类</li></ul> <p>匿名内部类只没有名字的内部类，在日常开发中使用较多。使用匿名内部类的前提条件：必须继承一个父类或实现一个接口。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello,word&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>静态内部类</li></ul> <p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字 <code>static</code> 。静态内部类是不需要依赖于外部类的，并且它不能使用外部类的非 static 成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非<code>static</code>成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Outter</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Outter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//报错，静态内部类不能访问非静态变量</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Outter</span><span class="token punctuation">.</span><span class="token class-name">Inner</span> inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outter</span><span class="token punctuation">.</span><span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>内部类的优点：</p> <ol><li>内部类不为同一包的其他类所见，具有很好的封装性；</li> <li>匿名内部类可以很方便的定义回调。</li> <li>每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实 现，对于内部类都没有影响。</li> <li>内部类有效实现了“多重继承”，优化 java单继承的缺陷。</li></ol> <ul><li>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上<code>final</code>？</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         
   <span class="token punctuation">}</span>
     
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于变量 <code>a</code>可以从生命周期的角度理解，局部变量直接存储在栈中，当方法执行结束后，非<code>final</code> 的局部变量就被销毁，而局部内部类对局部变量的引用依然存在，如果局部内部类要调用没有 <code>final</code>修饰的局部变量时，就会造成生命周期不一致出错。</p> <p>对于变量<code>b</code> ，其实是将 <code>fun</code>方法中的变量 <code>b</code>以参数的形式对匿名内部类中的拷贝（变量 <code>b</code> 的拷贝） 进行赋值初始化。在<code>run</code>方法中访问的变量 <code>b</code> 根本就不是 test 方法中的局部变量<code>b</code> ，而是一个拷 贝值，所以不存在生命周期不一致的问题，但如果在 run 方法中修改变量 <code>b</code>的值会导致数据不一 致，所以需要加 <code>final</code>修饰。</p> <h2 id="重写与重载"><a href="#重写与重载" class="header-anchor">#</a> 重写与重载</h2> <h4 id="重载和重写的区别"><a href="#重载和重写的区别" class="header-anchor">#</a> 重载和重写的区别</h4> <ul><li><p><strong>重载</strong>：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与 方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分。</p></li> <li><p><strong>重写</strong>：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于 父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为 private 则子类中 就不是重写。</p></li></ul> <h4 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="header-anchor">#</a> 构造器（constructor）是否可被重写（override）</h4> <p>构造器可以被重载，不能被重写</p> <h2 id="和-equals-的区别"><a href="#和-equals-的区别" class="header-anchor">#</a> == 和 equals 的区别</h2> <ul><li>==</li></ul> <p>对于基本数据类型，<code>==</code> 比较的是值；对于引用数据类型， <code>==</code>比较的是内存地址。</p> <ul><li>equals</li></ul> <p>对于没有重写<code>equals</code>方法的类， <code>equals</code>方法和 <code>==</code>作用类似；(但是在实际应用中，该方法不能满足的我们的需求。因为我们认为两个对象即使不是指向的同一块内存，只要这两个对象的各个字段属性值都相同，那么就认为这两个对象是同一个对象。所以就需要重写<code>equals（）</code>方法，即如果两个对象指向内存地址相同或者两个对象各个字段值相同,那么就是同一个对象)对于重写过 <code>equals</code>方法的类，<code>equals</code>比较的是值。</p> <h2 id="hashcode-与-equals（为什么重写equals方法后，-hashcode方法也必须重写）"><a href="#hashcode-与-equals（为什么重写equals方法后，-hashcode方法也必须重写）" class="header-anchor">#</a> hashCode 与 equals（为什么重写equals方法后， hashCode方法也必须重写）</h2> <ul><li><code>equals</code></li></ul> <p>先看下 <code>String</code> 类中重写的 <code>equals</code>方法。</p> <div class="language-java extra-class"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>anObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> anotherString <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>anObject<span class="token punctuation">;</span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">char</span> v1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
                <span class="token keyword">char</span> v2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>v1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> v2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                    i<span class="token operator">++</span><span class="token punctuation">;</span>
               <span class="token punctuation">}</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre></div><p>从源码中可以看到：</p> <ol><li><code>equals</code>方法首先比较的是内存地址，如果内存地址相同，直接返回<code>true</code> ；如果内存地址不同，再比较对象的类型，类型不同直接返回<code>false</code> ；类型相同，再比较值是否相同；值相同返回 <code>true</code> ，值不同返回 <code>false</code>。总结一下， <code>equals</code> 会比较内存地址、对象类型、以及值， 内存地址相同， <code>equals</code> 一定返回 <code>true</code>；对象类型和值相同， <code>equals</code>方法一定返回 <code>true</code> 。</li> <li>如果没有重写 <code>equals</code> 方法，那么<code>equals</code> 和 <code>==</code>的作用相同，比较的是对象的地址值。</li></ol> <ul><li><code>hashCode</code></li></ul> <p><code>hashCode</code>方法返回对象的散列码，返回值是 <code>int</code>类型的散列码。散列码的作用是确定该对象在哈希表中的索引位置。</p> <p>关于<code>hashCode</code>有一些约定：</p> <ol><li>两个对象相等，则<code>hashCode</code> 一定相同。</li> <li>两个对象有相同的 <code>hashCode</code> 值，它们不一定相等。</li> <li><code>hashCode()</code>方法默认是对堆上的对象产生独特值，如果没有重写 <code>hashCode()</code> 方法，则该类 的两个对象的<code>hashCode</code>值肯定不同</li></ol> <ul><li><p>为什么重写 <code>equals</code>方法后，<code>hashCode</code> 方法也必须重写</p> <p><code>hashCode</code> 在具有哈希机制的集合中起着非常关键的作用，比如 <code>HashMap</code>、 <code>HashSet</code> 等。以 <code>HashSet</code> 为例， <code>HashSet</code> 的特点是存储元素时无序且唯一，在向 <code>HashSet</code>中添加对象时，首先会计算对象的 <code>HashCode</code> 值来确定对象的存储位置，如果该位置没有其他对象，直接将该对象添加到该位置；如果该存储位置有存储其他对象（新添加的对象和该存储位置的对象的 <code>HashCode</code>值相同），调用 <code>equals</code> 方法判断两个对象是否相同，如果相同，则添加对象失败，如果不相同，则会将该对象重新散列到其他位置。所以重写 <code>equals</code>方法后， <code>hashCode</code> 方法不重写的话，会导致所有对象的 <code>HashCode</code> 值都不相同，都能添加成功，那么 <code>HashSet</code>中会出现很多重复元素， <code>HashMap</code>也是同理（因为 <code>HashSet</code>的底层就是通过 <code>HashMap</code>实现 的），会出现大量相同的 <code>Key</code>（<code>HashMap</code> 中的 <code>key</code>是唯一的，但不同的 <code>key</code> 可以对应相同的<code>value</code> ）。所以重写 <code>equals</code>方法后，<code>hashCode</code> 方法也必须重写。同时因为两个对象的 <code>hashCode</code>值不同，则它们一定不相等，所以先计算对象的<code>hashCode</code> 值可以在一定程度上判 断两个对象是否相等，提高了集合的效率。总结一下，<strong>一共两点：第一，在 <code>HashSet</code> 等集合 中，不重写<code>hashCode</code> 方法会导致其功能出现问题；第二，可以提高集合效率</strong>。</p></li></ul> <p><strong>如果不重写hashcode</strong></p> <p>对于对象集合的判重，如果一个集合含有100个对象实例，仅仅使用equals()方法的话，那么对于一个对象判重就需要比较4950次，随着集合规模的增大，时间开销是很大的。但是同时使用哈希表的话，就能快速定位到对象的大概存储位置，并且在定位到大概存储位置后，后续比较过程中，如果两个对象的hashCode不相同，也不再需要调用equals（）方法，从而大大减少了equals()比较次数。所以从程序实现原理上来讲的话，既需要equals()方法，也需要hashCode()方法。那么既然重写了equals（），那么也要重写hashCode()方法，以保证两者之间的配合关系。</p> <h2 id="java-中是值传递还是引用传递"><a href="#java-中是值传递还是引用传递" class="header-anchor">#</a> Java 中是值传递还是引用传递</h2> <blockquote><p>Java里面只有值传递</p></blockquote> <p>先看一段代码</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token function">printValue</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;a:&quot;</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
        b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;b:&quot;</span><span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出</p> <div class="language-java extra-class"><pre class="language-java"><code>b<span class="token operator">:</span><span class="token number">2</span>
a<span class="token operator">:</span><span class="token number">1</span>
</code></pre></div><p>可以看到将 a 的值传到 <code>printValue</code>方法中，并将其值改为2。但方法调用结束后，<code>a</code> 的值还是1，并未发生改变，所以这种情况下为值传递。</p> <p>再看这段代码</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Preson</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Preson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;zhangsan&quot;</span><span class="token punctuation">;</span>
        <span class="token function">printValue</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;p.name: &quot;</span> <span class="token operator">+</span> p<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token class-name">Preson</span> q<span class="token punctuation">)</span><span class="token punctuation">{</span>
        q<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;lisi&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;q.name: &quot;</span><span class="token operator">+</span> q<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Preson</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出结果</p> <div class="language-java extra-class"><pre class="language-java"><code>q<span class="token punctuation">.</span>name<span class="token operator">:</span> lisi
p<span class="token punctuation">.</span>name<span class="token operator">:</span> lisi
</code></pre></div><p>在将 <code>p</code> 传入 printValue 方法后，方法调用结束， <code>p</code>的<code>name</code>属性竟然被改变了！所以得出结论，参数为基本类型为值传递，参数为引用类型为时为引用传递。这个结论是错误的，下面来看看判断是值传递还是值传递的关键是什么，先看定义</p> <ul><li>值传递：是指在调用函数时将实际参数<strong>复制一份</strong>传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</li> <li>引用传递：是指在调用函数时将实际参数的<strong>地址直接传递</strong>到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</li></ul> <p>从定义中可以明显看出，区分是值传递还是引用传递主要是看<strong>向方法中传递的是实际参数的副本还是实际参数的地址</strong>。上面第一个例子很明显是值传递，其实第二个例子中向 printValue 方法中传递的是一个引用的副本，只是这个副本引用和原始的引用指向的同一个对象，所以副本引用修改过对象属性后， 通过原始引用查看对象属性肯定也是被修改过的。换句话说， printValue 方法中修改的是副本引用指向的对象的属性，不是引用本身，如果修改的是引用本身，那么原始引用肯定不受影响。看下面这个例子</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Preson</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Preson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;zhangsan&quot;</span><span class="token punctuation">;</span>
        <span class="token function">printValue</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;p.name: &quot;</span> <span class="token operator">+</span> p<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token class-name">Preson</span> q<span class="token punctuation">)</span><span class="token punctuation">{</span>
        q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Preson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        q<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;lisi&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;q.name: &quot;</span><span class="token operator">+</span> q<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Preson</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出结果</p> <div class="language-java extra-class"><pre class="language-java"><code>q<span class="token punctuation">.</span>name<span class="token operator">:</span> lisi
p<span class="token punctuation">.</span>name<span class="token operator">:</span> zhangsan
</code></pre></div><p>可以看到将<code>p</code>传入 <code>printValue</code>方法后，<code>printValue</code>方法调用结束后， <code>p</code>的属性 <code>name</code> 没有改变，这是因为在 <code>printValue</code> 方法中并没有改变副本引用 <code>q</code>所指向的对象，而是改变了副本引用 <code>q</code>本身，将副本引用 <code>q</code> 指向了另一个对象并对这个对象的属性进行修改，所以原始引用 <code>p</code> 所指向的对象不受影响。所以证明<code>Java</code>中只存在值传递。</p> <h2 id="io流"><a href="#io流" class="header-anchor">#</a> IO流</h2> <p>Java IO流主要可以分为输入流和输出流。按照照操作单元划分，可以划分为字节流和字符流。按照流的 角色划分为节点流和处理流。</p> <p>Java I0流的40多个类都是从4个抽象类基类中派生出来的。</p> <ul><li>InputStream：字节输入流</li> <li>Reader：字符输入流</li> <li>OutputStream：字节输出流</li> <li>Writer：字符输出流</li></ul> <p>IO流体系</p> <p><img src="https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209051629534.png" alt="img"></p> <h4 id="io流的设计模式"><a href="#io流的设计模式" class="header-anchor">#</a> IO流的设计模式</h4> <p>使用了<strong>适配器模式</strong>和<strong>装饰器模式</strong></p> <p><strong>适配器模式</strong>：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Reader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">INputStreamReader</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作</strong></p> <ul><li><strong>类适配器</strong>：Adapter类（适配器）继承Adaptee类（源角色）实现Target接口（目标角色）</li> <li><strong>对象适配器</strong>：Adapter类（适配器）持有Adaptee类（源角色）对象实例，实现Target接口（目标角色） <img src="https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209051629381.png" alt="img"></li></ul> <p><strong>装饰器模式</strong>：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>一种动态地往一个类中添加新的行为的设计模式。就功能而言，装饰器模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。</strong></p> <ul><li>ConcreteComponent（具体对象）和Decorator（抽象装饰器）实现相同的Conponent（接口）并且Decorator（抽象装饰器）里面持有Conponent（接口）对象，可以传递请求。</li> <li>ConcreteComponent（具体装饰器）覆盖Decorator（抽象装饰器）的方法并用super进行调用，传递请求。</li></ul> <p><img src="https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209051629505.png" alt="img"></p> <h4 id="io多路复用和零拷贝"><a href="#io多路复用和零拷贝" class="header-anchor">#</a> IO多路复用和零拷贝</h4> <p>可以去看我的博客http://blog.fuxuyu.top/posts/2.html</p> <h2 id="异常"><a href="#异常" class="header-anchor">#</a> 异常</h2> <p>Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。</p> <p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p> <ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。<code>Exception</code> 又可以分为运行时异常(RuntimeException, 又叫非受检查异常)和非运行时异常(又叫受检查异常) 。</li> <li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复。</li></ul> <p>异常框架图：</p> <p><img src="https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209051629422.png" alt="image-20220418202024904"></p> <h4 id="非受检查异常-运行时异常-和受检查异常-一般异常-区别是什么？"><a href="#非受检查异常-运行时异常-和受检查异常-一般异常-区别是什么？" class="header-anchor">#</a> 非受检查异常(运行时异常)和受检查异常(一般异常)区别是什么？</h4> <p><strong>非受检查异常</strong>：该类异常包括运行时异常（<code>RuntimeException</code>极其子类）和错误（<code>Error</code>）。编译器不会进行检查并且不要求必须处理的异常，也就说当程序中出现此 类异常时，即使我们没有<code>try-catch</code>捕获它，也没有使用 <code>throws</code> 抛出该异常，编译也会正常通过。因为这样的异常发生的原因很可能是代码写的有问题。例如：<code>NullPointException(空指针)</code>、<code>NumberFormatException（字符串转换为数字）</code>、<code>IndexOutOfBoundsException(数组越界)</code>、<code>ClassCastException(类转换异常)</code>、<code>ArrayStoreException(数据存储异常，操作数组时类型不一致)</code>等。</p> <p><strong>受检查异常</strong>：是Exception 中除 <code>RuntimeException</code> 及其子类之外的异常。 Java 编译器会检查受检查异常。这是编译器 要求必须处理的异常。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未 知的环境下，而程序员无法干预用户如何使用他编写的程序，所以必须处理这些异常。常见的受检查异常有： IO相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>等。</p> <p><strong>非受检查异常和受检查异常之间的区别</strong>：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检查异常，否则就选择非受检查异常。</p> <h4 id="try-catch-finally的执行顺序"><a href="#try-catch-finally的执行顺序" class="header-anchor">#</a> <code>try</code>,<code>catch</code>,<code>finally</code>的执行顺序</h4> <ol><li>先执行<code>try</code> 中的语句，包括<code>return</code>后面的表达式；</li> <li>有异常时,执行 <code>catch</code>中的语句，包括 <code>return</code>后面的表达式，无异常跳过 <code>catch</code>语句；</li> <li>然后执行 <code>finally</code> 中的语句，如果 <code>finally</code> 里面有 <code>return</code> 语句，执行 <code>return</code>语句，程序结束；</li> <li><code>finally</code> 中没有 <code>return</code>时，无异常执行 <code>try</code>中的 <code>return</code>，如果有异常时则执行 <code>catch</code> 中的 <code>return</code> 。前两步执行的 ```return<code>只是确定返回的值，程序并未结束，</code>finally<code>执行之后，最后 将前两步确定的</code> return ``的返回值返回。</li></ol> <h2 id="注解"><a href="#注解" class="header-anchor">#</a> 注解</h2> <p><code>Annotation</code> 注解可以看成是java中的一种标记记号，用来给java中的类，成员，方法，参数等任何程 序元素添加一些额外的说明信息，同时不改变程序语义。注解可以分为三类：基本注解，元注解，自定 义注解</p> <ul><li>标准注解</li></ul> <ol><li><strong>@Deprecated</strong>：该注解用来说明程序中的某个元素（类，方法，成员变量等）已经不再使 用，如果使用的话的编译器会给出警告。</li> <li><strong>@SuppressWarnings(value=“”)</strong>：用来抑制各种可能出现的警告。</li> <li><strong>@Override</strong>：用来说明子类方法覆盖了父类的方法，保护覆盖方法的正确使用</li></ol> <ul><li>元注解（元注解也称为元数据注解，是对注解进行标注的注解，元注解更像是一种对注解的规范说 明，用来对定义的注解进行行为的限定。例如说明注解的生存周期，注解的作用范围等）</li></ul> <ol><li><strong>@Target(value=“ ”)</strong>：该注解是用来限制注解的使用范围的，即该注解可以用于哪些程序元 素。</li> <li><strong>@Retention(value=“ ”)</strong>：用于说明注解的生存周期</li> <li><strong>@Documnent</strong>：用来说明指定被修饰的注解可以被javadoc.exe工具提取进入文档中，所有使 用了该注解进行标注的类在生成API文档时都在包含该注解的说明。</li> <li><strong>@Inherited</strong>：用来说明使用了该注解的父类，其子类会自动继承该注解。</li> <li><strong>@Repeatable</strong>：java1.8新出的元注解，如果需要在给程序元素使用相同类型的注解，则需将 该注解标注上。</li></ol> <ul><li>自定义注解：用@Interface来声明注解。</li></ul> <h2 id="泛型"><a href="#泛型" class="header-anchor">#</a> 泛型</h2> <p>Java 泛型是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译 时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p> <h4 id="泛型的好处"><a href="#泛型的好处" class="header-anchor">#</a> 泛型的好处</h4> <ol><li>类型安全
<ul><li>泛型的主要目标是提高 Java 程序的类型安全</li> <li>编译时期就可以检查出因 Java 类型不正确导致的 ClassCastException 异常</li> <li>符合越早出错代价越小原则</li></ul></li> <li>消除强制类型转换
<ul><li>泛型的一个附带好处是，使用时直接得到目标类型，消除许多强制类型转换</li> <li>所得即所需，这使得代码更加可读，并且减少了出错机会</li></ul></li> <li>潜在的性能收益
<ul><li>由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改</li> <li>所有工作都在编译器中完成</li> <li>编译器生成的代码跟不使用泛型（和强制类型转换）时所写的代码几乎一致，只是更能确保类型安全而已</li></ul></li></ol> <h4 id="泛型擦除"><a href="#泛型擦除" class="header-anchor">#</a> 泛型擦除</h4> <p>Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息 的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。看下面代码</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> arrayList1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> arrayList2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arrayList1<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> arrayList2<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出结果</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token boolean">true</span>
</code></pre></div><p>可以看到 <code>ArrayList</code> 和<code>ArrayList</code> 的原始类型是相同，在编译成字节码文件 后都会变成<code>List</code>，JVM看到的只有 <code>List</code>，看不到泛型信息，这就是泛型的类型擦除。在看下面这 段代码</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> arrayList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        arrayList<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">&quot;add&quot;</span><span class="token punctuation">,</span> 
<span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token number">1</span>
a
</code></pre></div><p>可以看到通过反射进行<code>add</code>操作， <code>ArrayList</code> 竟然可以存储字符串，这是因为在反射 就是在运行期调用的<code>add</code>方法，在运行期泛型信息已经被擦除。</p> <ul><li>既然存在类型擦除，那么Java是如何保证在 <code>ArrayList</code> 添加字符串会报错呢？ Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。</li></ul> <h4 id="判断arraylist与arraylist是否相等？"><a href="#判断arraylist与arraylist是否相等？" class="header-anchor">#</a> 判断<code>ArrayList</code>与<code>ArrayList</code>是否相等？</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Class</span> c1 <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Class</span> c2 <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c1 <span class="token operator">==</span> c2<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><ul><li>输出的结果是 true。因为无论对于 ArrayList 还是 ArrayList，它们的 Class 类型都是一直的，都是 ArrayList.class。</li> <li>那它们声明时指定的 String 和 Integer 到底体现在哪里呢？</li></ul> <p>**答案是体现在类编译的时候。**当 JVM 进行类编译时，会进行泛型检查，如果一个集合被声明为 String 类型，那么它往该集合存取数据的时候就会对数据进行判断，从而避免存入或取出错误的数据。</p> <h2 id="序列化"><a href="#序列化" class="header-anchor">#</a> 序列化</h2> <p>Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程</p> <ul><li><p>**序列化：**序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。核心作用是对象状态的保存与重建。我们都知道，Java对象是保存在JVM的堆内存中的，也就是说，如果JVM堆不存在了，那么对象也就跟着消失了。</p> <p>而序列化提供了一种方案，可以让你在即使JVM停机的情况下也能把对象保存下来的方案。就像我们平时用的U盘一样。把Java对象序列化成可存储或传输的形式（如二进制流），比如保存在文件中。这样，当再次需要这个对象的时候，从文件中读取出二进制流，再从二进制流中反序列化出对象。</p></li> <li><p>**反序列化：**客户端从文件中或网络上获得序列化后的对象字节流，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p></li> <li><p>序列化的方式：实现<strong>Serializable</strong>接口或者<strong>Externalizable</strong>接口。</p> <ul><li><code>Externalizable</code>继承自<code>Serializable</code>，该接口中定义了两个抽象方法：<code>writeExternal()</code>与<code>readExternal()</code>。</li></ul> <table><thead><tr><th style="text-align:center;">实现Serializable接口</th> <th style="text-align:center;">实现Externalizable接口</th></tr></thead> <tbody><tr><td style="text-align:center;">系统自动存储必要的信息</td> <td style="text-align:center;">程序员决定存储哪些信息</td></tr> <tr><td style="text-align:center;">Java内建支持，易于实现，只需要实现该接口即可，无需任何代码支持</td> <td style="text-align:center;">必须实现接口内的两个方法</td></tr> <tr><td style="text-align:center;">性能略差</td> <td style="text-align:center;">性能略好</td></tr></tbody></table></li> <li><p>序列化的注意事项：</p> <ol><li>对象的类名、实例变量会被序列化；方法、类变量、 <code>transient</code>实例变量都不会被序列化。</li> <li>某个变量不被序列化，可以使用 <code>transient</code>修饰。</li> <li>序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错。</li> <li>反序列化时必须有序列化对象的<code>class</code> 文件。</li></ol></li></ul> <h2 id="反射"><a href="#反射" class="header-anchor">#</a> 反射</h2> <p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个 对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java语言的反射机制。</p> <p>Java获取Class对象的四种方式</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">&quot;zhangsan&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
 <span class="token comment">//方式1</span>
     <span class="token class-name">Person</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token class-name">Class</span> c1 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment">//方式2</span>
    <span class="token class-name">Class</span> c2 <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
    <span class="token comment">//方式3可能会抛出ClassNotFoundException异常</span>
    <span class="token class-name">Class</span> c3 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;com.company&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment">//方式四：使用类的加载器：ClassLoader  (了解)</span>
    <span class="token class-name">ClassLoader</span> classLoader <span class="token operator">=</span> <span class="token class-name">ReflectionTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Class</span> c4 <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">&quot;www.gh110.com&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>因为在一个类在 JVM 中只会有一个<code>Class</code>实例，所以对<code>c1</code> 、 <code>c2</code>、 <code>c3</code>进行 <code>equals</code> 比较时返回的都是<code>true</code>。</p> <p><strong>反射优缺点：</strong></p> <ul><li><p>优点：运行期类型的判断，动态加载类，提高代码灵活度。</p></li> <li><p>缺点：性能比直接的java代码要慢很多。</p></li></ul> <p>反射应用场景：</p> <p><strong>1.Java的很多框架都用到了反射，例如 Spring 中的xml的配置模式等</strong></p> <p>​	Spring 通过 XML 配置模式装载 Bean 的过程：</p> <ul><li>将程序内所有 XML 或 Properties 配置文件加载入内存中；</li> <li>Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息；</li> <li>使用反射机制，根据这个字符串获得某个类的Class实例；</li> <li>动态配置实例的属性。</li></ul> <p>​	Spring这样做的好处是：</p> <ul><li>不用每一次都要在代码里面去new或者做其他的事情；</li> <li>以后要改的话直接改配置文件，代码维护起来就很方便了；</li> <li>有时为了适应某些需求，Java类里面不一定能直接调用另外的方法，可以通过反射机制来实现。</li></ul> <p><strong>2.动态代理设计模式也采用了反射机制</strong></p> <p><strong>3.JDBC 的数据库的连接</strong></p> <ul><li>通过Class.forName()加载数据库的驱动程序 （通过反射加载，前提是引入相关了Jar包）;</li> <li>通过 DriverManager 类进行数据库的连接，连接的时候要输入数据库的连接地址、用户名、密码；</li> <li>通过Connection 接口接收连接</li></ul> <h2 id="代理"><a href="#代理" class="header-anchor">#</a> 代理</h2> <h4 id="代理模式"><a href="#代理模式" class="header-anchor">#</a> <strong>代理模式</strong></h4> <p>​		代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务</p> <h4 id="静态代理"><a href="#静态代理" class="header-anchor">#</a> <strong>静态代理</strong></h4> <p>静态代理：由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口，被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。</p> <ul><li>简单实现</li></ul> <p>我这儿举一个比较粗糙的例子，假如一个班的同学要向老师交班费，但是都是通过班长把自己的钱转交给老师。这里，班长就是代理学生上交班费</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token comment">//上交班费</span>
    <span class="token keyword">void</span> <span class="token function">giveMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Student类实现Person接口。Student可以具体实施上交班费的动作。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">implements</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">giveMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">&quot;上交班费50元&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>StudentsProxy类，这个类也实现了Person接口，但是还另外持有一个学生类对象，由于实现了Peson接口，同时持有一个学生对象，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StudentsProxy</span> <span class="token keyword">implements</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
    <span class="token comment">//被代理的学生</span>
    <span class="token class-name">Student</span> stu<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">StudentsProxy</span><span class="token punctuation">(</span><span class="token class-name">Person</span> stu<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 只代理学生对象</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>stu<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>stu <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span>stu<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">//代理上交班费，调用被代理学生的上交班费行为</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">giveMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        stu<span class="token punctuation">.</span><span class="token function">giveMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//被代理的学生张三，他的班费上交有代理对象monitor（班长）完成</span>
        <span class="token class-name">Person</span> zhangsan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;张三&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">//生成代理对象，并将张三传给代理对象</span>
        <span class="token class-name">Person</span> monitor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StudentsProxy</span><span class="token punctuation">(</span>zhangsan<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">//班长代理上交班费</span>
        monitor<span class="token punctuation">.</span><span class="token function">giveMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><ul><li><p>优点：可以在不修改目标对象的前提下扩展目标对象的功能。</p></li> <li><p>缺点：</p></li> <li><ul><li><strong>冗余</strong>：由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。</li> <li><strong>不易维护</strong>：一旦接口增加方法，目标对象与代理对象都要进行修改。</li></ul></li></ul> <h4 id="动态代理"><a href="#动态代理" class="header-anchor">#</a> <strong>动态代理</strong></h4> <p>代理类在程序运行时创建的代理方式被成为动态代理。 我们上面静态代理的例子中，代理类(studentProxy)是自己定义好的，在程序运行之前就已经编译完成。然而动态代理，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法</p> <p>创建步骤：</p> <ul><li>创建一个InvocationHandler对象</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//创建一个与代理对象相关联的InvocationHandler</span>
<span class="token class-name">InvocationHandler</span> stuHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyInvocationHandler</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>使用Proxy类的getProxyClass静态方法生成一个动态代理类stuProxyClass</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> stuProxyClass <span class="token operator">=</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">getProxyClass</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>获得stuProxyClass 中一个带InvocationHandler参数的构造器constructor</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">=</span> <span class="token class-name">PersonProxy</span><span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token class-name">InvocationHandler</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>通过构造器constructor来创建一个动态实例stuProxy</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Person</span> stuProxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> cons<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>stuHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>动态代理的方式有两种：</strong></p> <ul><li>JDK动态代理：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</li> <li>CGLIB动态代理：利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</li></ul> <p>**区别：**JDK代理只能对实现接口的类生成代理；CGlib是针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法，这种通过继承类的实现方式，不能代理final修饰的类。</p> <h4 id="动态代理和静态代理的区别"><a href="#动态代理和静态代理的区别" class="header-anchor">#</a> 动态代理和静态代理的区别</h4> <ol><li>静态代理在编译时就已经实现，编译完成后代理类是一个实际的 class 文件</li> <li>动态代理是在运行时动态生成的，即编译完成后没有实际的 class 文件，而是在运行时动态生成类字节码，并加载到 <code>JVM</code> 中</li></ol></div> <footer class="page-edit" style="display:none;"><!----> <!----></footer> <!----> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.3bc42cf8.js" defer></script><script src="/assets/js/3.0146fe10.js" defer></script><script src="/assets/js/1.760be874.js" defer></script><script src="/assets/js/16.62996748.js" defer></script>
  </body>
</html>
