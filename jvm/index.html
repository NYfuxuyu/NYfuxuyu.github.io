<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JVM | 知识星球</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/avatar.jpg">
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.a26fb221.css" as="style"><link rel="preload" href="/assets/js/app.3bc42cf8.js" as="script"><link rel="preload" href="/assets/js/3.0146fe10.js" as="script"><link rel="preload" href="/assets/js/1.760be874.js" as="script"><link rel="preload" href="/assets/js/18.04a1e384.js" as="script"><link rel="prefetch" href="/assets/js/10.2fa36d92.js"><link rel="prefetch" href="/assets/js/11.d5259c34.js"><link rel="prefetch" href="/assets/js/12.3b11beda.js"><link rel="prefetch" href="/assets/js/13.8e606e78.js"><link rel="prefetch" href="/assets/js/14.7e273577.js"><link rel="prefetch" href="/assets/js/15.9080a48f.js"><link rel="prefetch" href="/assets/js/16.62996748.js"><link rel="prefetch" href="/assets/js/17.afa987aa.js"><link rel="prefetch" href="/assets/js/19.51469f95.js"><link rel="prefetch" href="/assets/js/20.180dc3cd.js"><link rel="prefetch" href="/assets/js/21.32d43e7f.js"><link rel="prefetch" href="/assets/js/22.f1326aa2.js"><link rel="prefetch" href="/assets/js/23.35607ff8.js"><link rel="prefetch" href="/assets/js/24.60cebcf3.js"><link rel="prefetch" href="/assets/js/25.4b8dd78e.js"><link rel="prefetch" href="/assets/js/26.13c2f0ff.js"><link rel="prefetch" href="/assets/js/4.a5370f7a.js"><link rel="prefetch" href="/assets/js/5.716a9c5a.js"><link rel="prefetch" href="/assets/js/6.048f2fb7.js"><link rel="prefetch" href="/assets/js/7.c3f4f112.js"><link rel="prefetch" href="/assets/js/8.64d54cc1.js"><link rel="prefetch" href="/assets/js/9.4411a8b9.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a26fb221.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-2d5f533b><div data-v-2d5f533b><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-2d5f533b data-v-2d5f533b><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-2d5f533b data-v-2d5f533b><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>知识星球</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>知识星球</span>
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-2d5f533b><header class="navbar" data-v-2d5f533b><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/avatar.jpg" alt="知识星球" class="logo"> <span class="site-name">知识星球</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      计算机基础
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/network/" class="nav-link"><i class="iconfont reco-network"></i>
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/operationsystem/" class="nav-link"><i class="iconfont reco-system"></i>
  操作系统
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-sql"></i>
      数据库
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mysql/" class="nav-link"><i class="iconfont undefined"></i>
  Mysql
</a></li><li class="dropdown-item"><!----> <a href="/sql/Redis.html" class="nav-link"><i class="iconfont undefined"></i>
  Redis
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-java"></i>
      Java基础
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/javase/" class="nav-link"><i class="iconfont undefined"></i>
  JavaSE
</a></li><li class="dropdown-item"><!----> <a href="/collection/" class="nav-link"><i class="iconfont undefined"></i>
  Java集合
</a></li><li class="dropdown-item"><!----> <a href="/juc/" class="nav-link"><i class="iconfont undefined"></i>
  Java并发
</a></li><li class="dropdown-item"><!----> <a href="/jvm/" class="nav-link router-link-exact-active router-link-active"><i class="iconfont undefined"></i>
  JVM
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      框架
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mybatis/" class="nav-link"><i class="iconfont undefined"></i>
  Mybaits
</a></li><li class="dropdown-item"><!----> <a href="/spring/" class="nav-link"><i class="iconfont undefined"></i>
  Spring
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      扩展
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/data/" class="nav-link"><i class="iconfont undefined"></i>
  海量数据
</a></li><li class="dropdown-item"><!----> <a href="/area/" class="nav-link"><i class="iconfont undefined"></i>
  系统设计题
</a></li><li class="dropdown-item"><!----> <a href="/suanfa/" class="nav-link"><i class="iconfont undefined"></i>
  算法
</a></li><li class="dropdown-item"><!----> <a href="/iq/" class="nav-link"><i class="iconfont undefined"></i>
  智力题
</a></li><li class="dropdown-item"><!----> <a href="/shejimoshi/" class="nav-link"><i class="iconfont undefined"></i>
  设计模式
</a></li></ul></div></div><div class="nav-item"><a href="http://blog.fuxuyu.top/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont undefined"></i>
  个人博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://gitee.com/fuxuyu" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-mayun"></i>
  码云
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/NYfuxuyu" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-2d5f533b></div> <aside class="sidebar" data-v-2d5f533b><div class="personal-info-wrapper" data-v-ca798c94 data-v-2d5f533b><!----> <h3 class="name" data-v-ca798c94>
    知识星球
  </h3> <div class="num" data-v-ca798c94><div data-v-ca798c94><h3 data-v-ca798c94>16</h3> <h6 data-v-ca798c94>Article</h6></div> <div data-v-ca798c94><h3 data-v-ca798c94>14</h3> <h6 data-v-ca798c94>Tag</h6></div></div> <hr data-v-ca798c94></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      计算机基础
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/network/" class="nav-link"><i class="iconfont reco-network"></i>
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/operationsystem/" class="nav-link"><i class="iconfont reco-system"></i>
  操作系统
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-sql"></i>
      数据库
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mysql/" class="nav-link"><i class="iconfont undefined"></i>
  Mysql
</a></li><li class="dropdown-item"><!----> <a href="/sql/Redis.html" class="nav-link"><i class="iconfont undefined"></i>
  Redis
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-java"></i>
      Java基础
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/javase/" class="nav-link"><i class="iconfont undefined"></i>
  JavaSE
</a></li><li class="dropdown-item"><!----> <a href="/collection/" class="nav-link"><i class="iconfont undefined"></i>
  Java集合
</a></li><li class="dropdown-item"><!----> <a href="/juc/" class="nav-link"><i class="iconfont undefined"></i>
  Java并发
</a></li><li class="dropdown-item"><!----> <a href="/jvm/" class="nav-link router-link-exact-active router-link-active"><i class="iconfont undefined"></i>
  JVM
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      框架
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mybatis/" class="nav-link"><i class="iconfont undefined"></i>
  Mybaits
</a></li><li class="dropdown-item"><!----> <a href="/spring/" class="nav-link"><i class="iconfont undefined"></i>
  Spring
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      扩展
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/data/" class="nav-link"><i class="iconfont undefined"></i>
  海量数据
</a></li><li class="dropdown-item"><!----> <a href="/area/" class="nav-link"><i class="iconfont undefined"></i>
  系统设计题
</a></li><li class="dropdown-item"><!----> <a href="/suanfa/" class="nav-link"><i class="iconfont undefined"></i>
  算法
</a></li><li class="dropdown-item"><!----> <a href="/iq/" class="nav-link"><i class="iconfont undefined"></i>
  智力题
</a></li><li class="dropdown-item"><!----> <a href="/shejimoshi/" class="nav-link"><i class="iconfont undefined"></i>
  设计模式
</a></li></ul></div></div><div class="nav-item"><a href="http://blog.fuxuyu.top/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont undefined"></i>
  个人博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://gitee.com/fuxuyu" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-mayun"></i>
  码云
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/NYfuxuyu" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-2d5f533b><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>JVM</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>知识星球</span>
            
          <!---->
          2022
        </a></span></div></div> <div data-v-2d5f533b><main class="page"><div class="page-title" style="display:none;"><h1 class="title">JVM</h1> <div data-v-3b7f5bdf><i class="iconfont reco-account" data-v-3b7f5bdf><span data-v-3b7f5bdf>仪轩</span></i> <i class="iconfont reco-date" data-v-3b7f5bdf><span data-v-3b7f5bdf>2022-09-16</span></i> <!----> <i class="iconfont reco-tag tags" data-v-3b7f5bdf><span class="tag-item" data-v-3b7f5bdf>JVM</span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><blockquote><p>JVM</p></blockquote> <h2 id="介绍下-java-内存区域-运行时数据区"><a href="#介绍下-java-内存区域-运行时数据区" class="header-anchor">#</a> 介绍下 Java 内存区域(运行时数据区)</h2> <p>JVM内存结构分为5大区域，程序计数器、虚拟机栈、本地方法栈、堆、方法区。</p> <p><img src="https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209121109698.png" alt="image-20220421172246031"></p> <h3 id="_1-1-程序计数器"><a href="#_1-1-程序计数器" class="header-anchor">#</a> 1.1 程序计数器</h3> <p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p> <p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p> <p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p> <ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li> <li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol> <p><strong>注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p> <h3 id="_1-2-java-虚拟机栈"><a href="#_1-2-java-虚拟机栈" class="header-anchor">#</a> 1.2 Java 虚拟机栈</h3> <p><strong>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p> <p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法返回值地址</strong>。）</p> <p><strong>局部变量表主要存放了编译期可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p> <p><strong>Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</strong></p> <ul><li><strong><code>StackOverFlowError</code>：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li> <li><strong><code>OutOfMemoryError</code>：</strong> 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出 OutOfMemoryError 错误。</li></ul> <p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p> <p><strong>扩展：那么方法/函数如何调用？</strong></p> <p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p> <p>Java 方法有两种返回方式：</p> <ol><li>return 语句。</li> <li>抛出异常。</li></ol> <p>不管哪种返回方式都会导致栈帧被弹出。</p> <p><strong>局部变量表(Local Variables)</strong></p> <p>局部变量表也被称之为局部变量数组或本地变量表</p> <ul><li>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各 类基本数据类型、对象引用（reference），以及 returnAddress 类型。</li> <li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</li> <li>局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的 Code 属性的 maximum local variables 数据项中。在方法运行期间是不会改变局部变量表的大小的。</li> <li>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参 数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之 销毁。</li></ul> <p><strong>关于 Slot 的理解</strong></p> <ul><li>局部变量表，最基本的存储单元是 Slot（变量槽）</li> <li>局部变量表中存放编译期可知的各种基本数据类型（8 种），引用类型（reference）， returnAddress 类型的变量。</li> <li>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 slot 处，其余的参数按照参数表顺序继续排列。</li></ul> <p><strong>操作数栈（Operand Stack）</strong></p> <p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的操作数栈， 也可以称之为表达式栈（Expression Stack）</p> <p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈 （pop）</p> <p><img src="https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209121109693.png" alt="image-20220421190352381"></p> <p><strong>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</strong></p> <p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次 数据访问</p> <p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新 PC 寄存器中 下一条需要执行的字节码指令。</p> <p>另外，我们说 Java 虚拟机的<strong>解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈。</p> <p><strong>动态链接</strong></p> <p>每一个栈帧内部都包含一个指向<strong>运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了 支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic 指令</p> <p>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在 class 文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常 量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong>。</p> <p><img src="https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209121109637.png" alt="image-20220421190913835"></p> <p><strong>方法返回地址</strong></p> <p>存放调用该方法的 pc 寄存器的值。一个方法的结束，有两种方式：</p> <ul><li>正常执行完成出现未处理的异常，</li> <li>非正常退出</li></ul> <p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 pc 计 数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p> <p><strong>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的 返回值。</strong></p> <table><thead><tr><th style="text-align:center;">运行时数据区</th> <th style="text-align:center;">是否存在 Error</th> <th style="text-align:center;">是否存在GC</th></tr></thead> <tbody><tr><td style="text-align:center;">程序计数器</td> <td style="text-align:center;">否</td> <td style="text-align:center;">否</td></tr> <tr><td style="text-align:center;">虚拟机栈</td> <td style="text-align:center;">是（SOE）</td> <td style="text-align:center;">否</td></tr> <tr><td style="text-align:center;">本地方法栈</td> <td style="text-align:center;">是</td> <td style="text-align:center;">否</td></tr> <tr><td style="text-align:center;">方法区</td> <td style="text-align:center;">是（OOM）</td> <td style="text-align:center;">是</td></tr> <tr><td style="text-align:center;">堆</td> <td style="text-align:center;">是</td> <td style="text-align:center;">是</td></tr></tbody></table> <h3 id="_1-3-本地方法栈"><a href="#_1-3-本地方法栈" class="header-anchor">#</a> 1.3 本地方法栈</h3> <p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p> <p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p> <p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p> <h3 id="_1-4-堆"><a href="#_1-4-堆" class="header-anchor">#</a> 1.4 堆</h3> <p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p> <p><strong>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 jdk 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</strong></p> <p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常被分为下面三部分：</p> <ol><li>新生代内存(Young Generation)</li> <li>老生代(Old Generation)</li> <li>永生代(Permanent Generation)</li></ol> <p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是<strong>直接内存</strong>。</p> <p><img src="https://images.xiaozhuanlan.com/photo/2020/4b64a69f721803e87171fee377a65436.png" alt="JVM堆内存结构-JDK7"></p> <p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置</p> <p>堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p> <ol><li><p><strong><code>OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</p></li> <li><p><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发<code>java.lang.OutOfMemoryError: Java heap space</code> 错误。(和本机物理内存无关，和你配置的内存大小有关！)</p></li></ol> <p><strong>堆的大小设置</strong></p> <ul><li>“-Xms&quot;用于表示堆区的起始内存，等价于 -XX:InitialHeapSize</li> <li>“-Xmx&quot;则用于表示堆区的最大内存，等价于 -XX:MaxHeapSize</li></ul> <p>通常会将-Xms 和-Xmx 两个参数配置相同的值，其目的是为了能够在 ava 垃圾回收机制清理完堆区后不 需要重新分隔计算堆区的大小，从而提高性能。</p> <p><strong>OutOfMemory 举例</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OOMTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Picture</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Picture</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Exception</span> in thread <span class="token string">&quot;main&quot;</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span><span class="token class-name">OutofMemoryError</span><span class="token operator">:</span> <span class="token class-name">Java</span> heap space
at com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span> java<span class="token punctuation">.</span><span class="token class-name">Picture</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span>init<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">OOMTest</span><span class="token punctuation">.</span> java<span class="token operator">:</span><span class="token number">25</span><span class="token punctuation">)</span>
at com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>java<span class="token punctuation">.</span><span class="token class-name">O0MTest</span><span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">OOMTest</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">16</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>堆是分配对象的唯一选择么？</strong></p> <p>随着 JIT 编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p> <p>在 Java 虚拟机中，对象是在 Java 堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那 就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优 化成栈上分配.。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p> <p>一、<strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远 不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</p> <p>二、<strong>同步省略</strong>：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同 步。</p> <p>三、<strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对 象的部分（或全部）可以不存储在内存，而是存储在 CPU 寄存器中。</p> <h3 id="_1-5-方法区"><a href="#_1-5-方法区" class="header-anchor">#</a> 1.5 方法区</h3> <p>方法区与 Java 堆一样，是各个线程共享的内存区域，存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据。即永久代，在jdk1.8中不存在方法区了，被元数据区替代了，原方法区被分成两部分；1：加载的类信息，2：运行时常量池；加载的类信息被保存在元数据区中，运行时常量池保存在堆中；</p> <p><strong>常用参数</strong></p> <p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token operator">-</span>XX<span class="token operator">:</span><span class="token class-name">PermSize</span><span class="token operator">=</span><span class="token class-name">N</span> <span class="token comment">//方法区 (永久代) 初始大小</span>
<span class="token operator">-</span>XX<span class="token operator">:</span><span class="token class-name">MaxPermSize</span><span class="token operator">=</span><span class="token class-name">N</span> <span class="token comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span>
</code></pre></div><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p> <p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p> <p>下面是一些常用参数：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token operator">-</span>XX<span class="token operator">:</span><span class="token class-name">MetaspaceSize</span><span class="token operator">=</span><span class="token class-name">N</span> <span class="token comment">//设置 Metaspace 的初始（和最小大小）</span>
<span class="token operator">-</span>XX<span class="token operator">:</span><span class="token class-name">MaxMetaspaceSize</span><span class="token operator">=</span><span class="token class-name">N</span> <span class="token comment">//设置 Metaspace 的最大大小</span>
</code></pre></div><p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p> <h3 id="_1-6-运行时常量池"><a href="#_1-6-运行时常量池" class="header-anchor">#</a> 1.6 运行时常量池</h3> <p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）</p> <p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p> <h3 id="_1-7-直接内存"><a href="#_1-7-直接内存" class="header-anchor">#</a> 1.7 直接内存</h3> <p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p> <h2 id="说一下-java-对象的创建过程"><a href="#说一下-java-对象的创建过程" class="header-anchor">#</a> 说一下 Java 对象的创建过程</h2> <p>下图便是 Java 对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。</p> <p><img src="https://images.xiaozhuanlan.com/photo/2020/e2cce6843053455fa8db43c78a8bc3b3.png" alt="Java创建对象的过程"></p> <h3 id="step1-类加载检查"><a href="#step1-类加载检查" class="header-anchor">#</a> Step1:类加载检查</h3> <p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p> <h3 id="step2-分配内存"><a href="#step2-分配内存" class="header-anchor">#</a> Step2:分配内存</h3> <p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p> <p><strong>内存分配的两种方式：</strong></p> <p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是&quot;标记-清除&quot;，还是&quot;标记-整理&quot;（也称作&quot;标记-压缩&quot;）</p> <p><img src="https://images.xiaozhuanlan.com/photo/2020/b7659cf62b39be898b99b8f4319095c7.png" alt="内存分配的两种方式"></p> <p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p> <p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p> <ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li> <li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li></ul> <h3 id="step3-初始化零值"><a href="#step3-初始化零值" class="header-anchor">#</a> Step3:初始化零值</h3> <p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p> <h3 id="step4-设置对象头"><a href="#step4-设置对象头" class="header-anchor">#</a> Step4:设置对象头</h3> <p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p> <h3 id="step5-执行-init-方法"><a href="#step5-执行-init-方法" class="header-anchor">#</a> Step5:执行 init 方法</h3> <p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p> <h2 id="对象的访问定位有哪两种方式"><a href="#对象的访问定位有哪两种方式" class="header-anchor">#</a> 对象的访问定位有哪两种方式</h2> <p>Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>① 使用句柄</strong>和<strong>② 直接指针</strong>两种：</p> <ol><li><p><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</p> <p><img src="https://images.xiaozhuanlan.com/photo/2020/a902849be548efa99760deafdfa726c5.png" alt="对象的访问定位-使用句柄"></p> <p>对象的访问定位-使用句柄</p></li> <li><p><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p></li></ol> <p><img src="https://images.xiaozhuanlan.com/photo/2020/a22870669795f8da8f8d0a71b89d340c.png" alt="对象的访问定位-直接指针"></p> <p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p> <h2 id="堆内存中对象的分配的基本策略"><a href="#堆内存中对象的分配的基本策略" class="header-anchor">#</a> 堆内存中对象的分配的基本策略</h2> <p><strong>对象优先在 Eden 分配</strong></p> <p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，触发 Minor GC 。</p> <p><strong>大对象直接进入老年代</strong> 大对象是指需要连续内存空间的对象，最典型的大对象有长字符串和大数组。可以设置JVM参数 - XX:PretenureSizeThreshold ，大于此值的对象直接在老年代分配。</p> <p><strong>长期存活的对象进入老年代</strong></p> <p>通过参数<code>-XX:MaxTenuringThreshold</code>可以设置对象进入老年代的年龄阈值。对象在 Survivor 区每经 过一次 Minor GC ，年龄就增加 1 岁，当它的年龄增加到一定程度，就会被晋升到老年代中。</p> <p><strong>动态对象年龄判定</strong></p> <p>并非对象的年龄必须达到 <code>MaxTenuringThreshold</code>才能晋升老年代，如果在 Survivor 中相同年龄所 有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代， 无需达到 <code>MaxTenuringThreshold</code>年龄阈值。</p> <p><strong>空间分配担保</strong></p> <p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如 果条件成立的话，那么 Minor GC 是安全的。如果不成立的话虚拟机会查看 <code>HandlePromotionFailure</code>的值是否允许担保失败。如果允许，那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC ；如果 小于，或者 <code>HandlePromotionFailure</code>的值为不允许担保失败，那么就要进行一次 Full GC 。</p> <h2 id="如何判断对象是否死亡-两种方法"><a href="#如何判断对象是否死亡-两种方法" class="header-anchor">#</a> 如何判断对象是否死亡?(两种方法)</h2> <ul><li><strong>引用计数法</strong></li></ul> <p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p> <p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceCountingGc</span> <span class="token punctuation">{</span>
    <span class="token class-name">Object</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ReferenceCountingGc</span> objA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ReferenceCountingGc</span> objB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        objA<span class="token punctuation">.</span>instance <span class="token operator">=</span> objB<span class="token punctuation">;</span>
        objB<span class="token punctuation">.</span>instance <span class="token operator">=</span> objA<span class="token punctuation">;</span>
        objA <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        objB <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟</p> <p>缺点：</p> <ol><li>需要单独的存储计数器，增加了空间的开销</li> <li>每次赋值都需要更新计数器，增加了时间开销</li> <li>无法处理循环引用的问题</li></ol> <ul><li><strong>可达性分析算法</strong></li></ul> <p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p> <p><img src="https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209121109609.png" alt="image-20220422112523681"></p> <p>可作为 <strong>GC Roots</strong> 的对象包括下面几种:</p> <ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li> <li>本地方法栈(Native 方法)中引用的对象</li> <li>方法区中类静态属性引用的对象</li> <li>方法区中常量引用的对象</li> <li>所有被同步锁synchronized持有的对象</li> <li>Jaca虚拟机的内部引用</li></ul> <h2 id="对象的-finalization-机制"><a href="#对象的-finalization-机制" class="header-anchor">#</a> 对象的 finalization 机制</h2> <p>Java 语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。 当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 finalize() 方法。</p> <p>永远不要主动调用某个对象的 finalize()方法 应该交给垃圾回收机制调用。理由包括下面三点：</p> <ul><li>在finalize的时候可能导致对象存活</li> <li>finalize的执行时间没有保障，完全由GC线程决定，极端情况，不发生GC，则没有执行机会</li> <li>一个糟糕的finalize将影响GC的性能</li></ul> <p>虚拟机中的对象一般处于三种可能的状态。</p> <ul><li>可触及的：从根节点开始，可以到达这个对象</li> <li>可复活的：对象的所有引用都被释放，但对象可能在finalize复活</li> <li>不可触及的：对象的finalize被调用，并且没有复活，那么就进入不可触及的状态，不可触及的不可以被复活，因为finalize只会被调用一次</li></ul> <h2 id="判断一个对象是否可以被回收"><a href="#判断一个对象是否可以被回收" class="header-anchor">#</a> 判断一个对象是否可以被回收</h2> <ol><li>如果对象objA到GC roots没有引用链，则进行第一次标记</li> <li>进行筛选，判断是否有必要执行finalize方法</li> <li>如果对象没有重写finalize方法或者finalize方法已经被虚拟机调用过了，则虚拟机没有必要执行，objA被判断定不可触及</li> <li>如果一个对象重写了finalize方法，且还未执行过，那么objA会插入F-Queue队列中，由一个虚拟机自动创建的，低优先级的Finalizer线程触发其finalize方法执行</li> <li><strong>finalize方法是对象逃脱死亡的最后机会</strong>，稍后GC会对F-Queue队列的对象进行二次标记。如果objA在finalize方法与引用链上任何一个对象建立了联系，那么二次标记的时候，objA对移除即将回收的集合。之后，对象会再次出现没有引用存在的情况，这个情况下，finalize不会被调用，对象直接变成不可触及的状态，也就是说，一个对象的finalize方法只会调用一次</li></ol> <h2 id="简单的介绍一下强引用-软引用-弱引用-虚引用"><a href="#简单的介绍一下强引用-软引用-弱引用-虚引用" class="header-anchor">#</a> 简单的介绍一下强引用,软引用,弱引用,虚引用</h2> <p>强引用：在程序中普遍存在的引用赋值，类似 <code>Object obj = new Object()</code>这种引用关系。只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p> <p>软引用：如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//软引用</span>
<span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> softRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>弱引用：在进行垃圾回收时，不管当前内存空间足够与否，都会回收只具有弱引用的对象。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//弱引用</span>
<span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> weakRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>
</code></pre></div><p>虚引用：虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一 样，在任何时候都可能被垃圾回收。虚<strong>引用主要是为了能在对象被收集器回收时收到一个系统通知</strong>。</p> <p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p> <h2 id="如何判断一个常量是废弃常量"><a href="#如何判断一个常量是废弃常量" class="header-anchor">#</a> 如何判断一个常量是废弃常量</h2> <ol><li><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></li> <li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</li> <li><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li></ol> <p>假如在字符串常量池中存在字符串 &quot;abc&quot;，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 &quot;abc&quot; 就是废弃常量，如果这时发生内存回收的话而且有必要的话，&quot;abc&quot; 就会被系统清理出常量池了。</p> <h2 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="header-anchor">#</a> 如何判断一个类是无用的类</h2> <p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p> <ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li> <li>加载该类的 <code>ClassLoader</code> 已经被回收。</li> <li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul> <p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p> <h2 id="垃圾收集有哪些算法，各自的特点"><a href="#垃圾收集有哪些算法，各自的特点" class="header-anchor">#</a> 垃圾收集有哪些算法，各自的特点</h2> <blockquote><p>2个小tips</p></blockquote> <p><strong>Stop The World</strong></p> <p>Stop-the-World，简称 STW，指的是 GC 事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为 STW。</p> <p>可达性分析算法中枚举根节点（GC Roots）会导致所有 Java 执行线程停顿。</p> <p><strong>安全点</strong></p> <p>程序执行时并非在所有地方都能停顿下来开始 GC，只有在特定的位置才能停顿下来开始 GC，这些位置 称为“安全点（Safepoint）”。</p> <p>Safe Point 的选择很重要，如果太少可能导致 GC 等待的时间太长，如果太频繁可能导致运行时的性能 问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比 如：选择一些执行时间较长的指令作为 Safe Point，如方法调用、循环跳转和异常跳转等。</p> <h4 id="标记-清除算法"><a href="#标记-清除算法" class="header-anchor">#</a> 标记-清除算法</h4> <p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p> <ol><li><strong>效率问题</strong></li> <li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li></ol> <p><img src="https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209121109751.png" alt="image-20220422133623347"></p> <h4 id="复制算法"><a href="#复制算法" class="header-anchor">#</a> 复制算法</h4> <p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p> <p>特点：实现简单，运行高效，但可用内存缩小为了原来的一半，浪费空间。</p> <h4 id="标记整理算法"><a href="#标记整理算法" class="header-anchor">#</a> 标记整理算法</h4> <p>根据老年代的特点提出的一种标记算法，标记过程仍然与 标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存</p> <p><img src="https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209121109706.png" alt="image-20220422133825385"></p> <p>优点：</p> <ul><li>消除了标记-清除算法里面，内存区域分散的缺点，JVM只需要维持一个内存起始地址就行（指针碰撞）</li> <li>消除了复制算法，内存减半的高额代价</li></ul> <p>缺点：</p> <ul><li>效率低于复制算法</li> <li>移动对象，如果对象被其他对象引用，还需要调整引用的地址</li> <li>移动过程中，需要全程停止用户程序，也就是STW</li></ul> <h4 id="分代收集算法"><a href="#分代收集算法" class="header-anchor">#</a> 分代收集算法</h4> <p>根据各个年代的特点采用最适当的收集算法。</p> <p>一般将堆分为新生代和老年代。</p> <ul><li>新生代使用复制算法</li> <li>老年代使用标记清除算法或者标记整理算法</li></ul> <p>在新生代中，每次垃圾收集时都有大批对象死去，只有少量存活，使用复制算法比较合适，只需要付出少量存活对象的复制成本就可以完成收集。老年代对象存活率高，适合使用标记-清理或者标记-整理算法进行垃圾回收。</p> <h4 id="增量收集算法"><a href="#增量收集算法" class="header-anchor">#</a> 增量收集算法</h4> <p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种 Stop the World 的状态。在 Stop the World 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题， 即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生</p> <p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，<strong>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</strong>。</p> <p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过<strong>对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</strong></p> <p><strong>缺点</strong></p> <p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会<strong>使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</strong></p> <h4 id="分区算法"><a href="#分区算法" class="header-anchor">#</a> 分区算法</h4> <p>一般来说，在相同条件下，堆空间越大，一次 Gc 时所需要的时间就越长，有关 GC 产生的停顿也越长。 为了更好地控制 GC 产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次 GC 所产生的停顿。</p> <p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。</p> <p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间</p> <p><img src="https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209121109658.png" alt="image-20220422135906967"></p> <h2 id="常见的垃圾回收器有那些"><a href="#常见的垃圾回收器有那些" class="header-anchor">#</a> 常见的垃圾回收器有那些</h2> <p>垃圾回收器主要分为以下几种：<code>Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1</code> 。</p> <table><thead><tr><th style="text-align:center;">收集器</th> <th style="text-align:center;">串行、并行or并发</th> <th style="text-align:center;">新生代/老年代</th> <th style="text-align:center;">算法</th> <th style="text-align:center;">目标</th> <th style="text-align:center;">适用场景</th></tr></thead> <tbody><tr><td style="text-align:center;">Serial</td> <td style="text-align:center;">串行</td> <td style="text-align:center;">新生代</td> <td style="text-align:center;">复制算法</td> <td style="text-align:center;">响应速度优先</td> <td style="text-align:center;">单CPU环境下的Client模式</td></tr> <tr><td style="text-align:center;">ParNew</td> <td style="text-align:center;">并行</td> <td style="text-align:center;">新生代</td> <td style="text-align:center;">复制算法</td> <td style="text-align:center;">响应速度优先</td> <td style="text-align:center;">多CPU环境时在Server模式下与CMS配合</td></tr> <tr><td style="text-align:center;">Parallel Scavenge</td> <td style="text-align:center;">并行</td> <td style="text-align:center;">新生代</td> <td style="text-align:center;">复制算法</td> <td style="text-align:center;">吞吐量 优先</td> <td style="text-align:center;">在后台运算而不需要太多交互的任务</td></tr> <tr><td style="text-align:center;">Serial Old</td> <td style="text-align:center;">串行</td> <td style="text-align:center;">老年代</td> <td style="text-align:center;">标记-整理</td> <td style="text-align:center;">响应速度优先</td> <td style="text-align:center;">单CPU环境下的Client模 式、CMS的后备预案</td></tr> <tr><td style="text-align:center;">Parallel Old</td> <td style="text-align:center;">并行</td> <td style="text-align:center;">老年代</td> <td style="text-align:center;">标记-整理</td> <td style="text-align:center;">吞吐量 优先</td> <td style="text-align:center;">在后台运算而不需要太多交互的任务</td></tr> <tr><td style="text-align:center;">CMS</td> <td style="text-align:center;">并发</td> <td style="text-align:center;">老年代</td> <td style="text-align:center;">标记-整理</td> <td style="text-align:center;">响应速度优先</td> <td style="text-align:center;">集中在互联网站或B/S系统 服务端上的Java应用</td></tr> <tr><td style="text-align:center;">G1</td> <td style="text-align:center;">并发</td> <td style="text-align:center;">both</td> <td style="text-align:center;">标记-整理 +复制算法</td> <td style="text-align:center;">响应速度优先</td> <td style="text-align:center;">面向服务端应用，将来替换 CMS</td></tr></tbody></table> <p><strong>Serial 收集器</strong></p> <p><strong>单线程收集器</strong>，使用一个垃圾收集线程去进行垃圾回收，在进行垃圾回收的时候必须暂停其他所有的工 作线程（<code>Stop The World</code>），直到它收集结束。</p> <p>特点：简单高效；内存消耗小；没有线程交互的开销，单线程收集效率高；需暂停所有的工作线程，用 户体验不好。</p> <p><strong>ParNew 收集器</strong></p> <p><code>Serial</code>收集器的多线程版本，除了使用多线程进行垃圾收集外，其他行为、参数与 Serial 收集器基本一致。</p> <p><strong>Parallel Scavenge 收集器</strong></p> <p><strong>新生代收集器</strong>，基于<strong>复制清除算法</strong>实现的收集器。特点是<strong>吞吐量优先</strong>，能够并行收集的多线程收集器， 允许多个垃圾回收线程同时运行，降低垃圾收集时间，提高吞吐量。所谓吞吐量就是 CPU 中用于运行用 户代码的时间与 CPU 总消耗时间的比值（ <strong>吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间</strong>） ）。<code>Parallel Scavenge</code> 收集器关注点是吞吐量，高效率的利用 CPU 资源。 CMS 垃圾收集器关注点更多的是用户线程的停顿时间</p> <p>Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 的 -XX：MaxGCPauseMillis 参数以及直接设置吞吐量大小的 -XX：GCTimeRatio 参数。</p> <ul><li><code>XX：MaxGCPauseMillis</code>参数的值是一个大于0的毫秒数，收集器将尽量保证内存回收花费的时间不超过用户设定值。</li> <li><code>-XX：GCTimeRatio</code> 参数的值大于0小于100，即垃圾收集时间占总时间的比率，相当于吞吐量的倒数。</li></ul> <p><strong>Serial Old 收集器</strong></p> <p>Serial 收集器的老年代版本，单线程收集器，使用标记整理算法。</p> <p><strong>Parallel Old 收集器</strong></p> <p>Parallel Scavenge 收集器的老年代版本。多线程垃圾收集，使用标记整理算法。</p> <p><strong>CMS 收集器</strong></p> <p>Concurrent Mark Sweep ，并发标记清除，追求获取<strong>最短停顿时间</strong>，实现了让<strong>垃圾收集线程与用户线程基本上同时工作</strong></p> <p><code>CMS</code>垃圾回收基于标记清除算法实现，整个过程分为四个步骤</p> <ul><li>初始标记： 暂停所有用户线程（ <code>Stop The World</code>），记录直接与 <code>GC Roots</code>直接相连的对象 。</li> <li>并发标记：从 <code>GC Roots</code>开始对堆中对象进行可达性分析，找出存活对象，耗时较长，但是不需要停顿用户线程</li> <li>重新标记： 在并发标记期间对象的引用关系可能会变化，需要重新进行标记。此阶段也会暂停所有用户线程。</li> <li>并发清除：清除标记对象，这个阶段也是可以与用户线程同时并发的。</li></ul> <p>在整个过程中，耗时最长的是并发标记和并发清除阶段，这两个阶段垃圾收集线程都可以与用户线程一 起工作，所以从总体上来说， CMS 收集器的内存回收过程是与用户线程一起并发执行的。</p> <p><strong>优点</strong>：并发收集，停顿时间短。</p> <p><strong>缺点</strong>：</p> <ul><li>标记清除算法导致收集结束有大量空间碎片。</li> <li>产生浮动垃圾，在并发清理阶段用户线程还在运行，会不断有新的垃圾产生，这一部分垃圾出现在 标记过程之后， CMS 无法在当次收集中回收它们，只好等到下一次垃圾回收再处理；</li></ul> <p><strong>G1收集器</strong></p> <p>G1垃圾收集器的目标是在不同应用场景中<strong>追求高吞吐量和低停顿之间的最佳平衡</strong></p> <p>G1将整个堆分成相同大小的分区（ Region ），有四种不同类型的分区： Eden、Survivor、Old和 Humongous 。分区的大小取值范围为 1M 到 32M，都是2的幂次方。分区大小可以通过<code>- XX:G1HeapRegionSize</code> 参数指定。 <code>Humongous</code>区域用于存储大对象。G1规定只要大小超过了一个分区容量一半的对象就认为是大对象</p> <p><img src="https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209121109372.png" alt="image-20220422142458133"></p> <p>G1 收集器对各个分区回收所获得的空间大小和回收所需时间的经验值进行排序，得到一个优先级列表， 每次根据用户设置的最大回收停顿时间，优先回收价值最大的分区。</p> <p><strong>特点</strong>：可以由用户指定期望的垃圾收集停顿时间。</p> <p>G1 收集器的回收过程分为以下几个步骤</p> <ul><li><strong>初始标记</strong>。暂停所有其他线程，记录直接与 <code>GC Roots</code>直接相连的对象，耗时较短 。</li> <li><strong>并发标记</strong>。从 <code>GC Roots</code> 开始对堆中对象进行可达性分析，找出要回收的对象，耗时较长，不过可以和用户程序并发执行。</li> <li><strong>最终标记</strong>。需对其他线程做短暂的暂停，用于处理并发标记阶段对象引用出现变动的区域。</li> <li><strong>筛选回收</strong>。对各个分区的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划， 然后把决定回收的分区的存活对象复制到空的分区中，再清理掉整个旧的分区的全部空间。这里的操作涉及存活对象的移动，会暂停用户线程，由多条收集器线程并行完成。</li></ul> <h2 id="类加载的过程"><a href="#类加载的过程" class="header-anchor">#</a> 类加载的过程</h2> <p>类的加载指的是将类的 class 文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内， 然后在堆区创建一个此类的对象，通过这个对象可以访问到方法区对应的类信息。</p> <p><img src="https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209121109566.png" alt="image-20220422142759303"></p> <p><strong>加载</strong></p> <ol><li>通过类的全限定名获取定义此类的二进制字节流</li> <li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li> <li>在内存中生成一个代表该类的<code>Class</code> 对象，作为方法区类信息的访问入口</li></ol> <p><strong>验证</strong></p> <ul><li>确保Class文件的字节流中包含的信息符合虚拟机规范，保证在运行后不会危害虚拟机自身的安全。主要 包括四种验证：<strong>文件格式验证</strong>，<strong>元数据验证</strong>，<strong>字节码验证</strong>，<strong>符号引用验证</strong>。</li></ul> <p><strong>准备</strong></p> <ul><li>为类变量分配内存并且设置该类变量的默认初始值，即零值。</li> <li>这里不包含用 <code>final</code>修饰的 <code>static</code>，因为<code>final</code> 在编译的时候就会分配了，准备阶段会显式初始化；</li> <li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到<code>Java</code> 堆中。</li></ul> <p><strong>解析</strong></p> <ul><li>将常量池内的符号引用转换为直接引用的过程。</li></ul> <p><strong>初始化</strong></p> <ul><li>初始化阶段就是执行类构造器方法&lt;clinit()&gt;的过程。</li></ul> <h2 id="类加载器的分类"><a href="#类加载器的分类" class="header-anchor">#</a> 类加载器的分类</h2> <p>实现通过类的全限定名获取该类的二进制字节流的代码块叫做类加载器.JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p> <ol><li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由 C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者或被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li> <li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</li> <li><strong>AppClassLoader(应用程序类加载器)</strong> :面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ol> <h2 id="双亲委派模型"><a href="#双亲委派模型" class="header-anchor">#</a> 双亲委派模型</h2> <p>一个类加载器收到一个类的加载请求时，它首先不会自己尝试去加载它，而是把这个请求委派给父类加载器去完成，这样层层委派，因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父类 加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。</p> <p><img src="https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209121109651.png" alt="image-20220422151006956"></p> <p>双亲委派模型的具体实现代码在 <code>java.lang.ClassLoader</code>中，此类的<code>loadClass()</code> 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 <code>ClassNotFoundException</code>，此时尝试自己去加载。源码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ClassLoader</span> parent<span class="token punctuation">;</span>
<span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 首先，检查请求的类是否已经被加载过</span>
            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">long</span> t0 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//父加载器不为空，调用父加载器loadClass()方法处理</span>
                        c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载</span>
                        c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                   <span class="token comment">//抛出异常说明父类加载器无法完成加载请求</span>
                <span class="token punctuation">}</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">long</span> t1 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">//自己尝试加载</span>
                    c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

                    <span class="token comment">// this is the defining class loader; record the stats</span>
                    sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span><span class="token class-name">PerfCounter</span><span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span><span class="token class-name">PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span><span class="token class-name">PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> c<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><h2 id="为什么需要双亲委派模型"><a href="#为什么需要双亲委派模型" class="header-anchor">#</a> 为什么需要双亲委派模型</h2> <p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p> <p><strong>避免类的重复加载 保护程序安全，防止核心 API 被随意篡改</strong></p> <h2 id="如何打破双亲委派机制"><a href="#如何打破双亲委派机制" class="header-anchor">#</a> 如何打破双亲委派机制</h2> <ul><li>自定义类加载器，继承<code>ClassLoader</code>类，重写<code>loadClass</code>方法和<code>findClass</code>方法。</li> <li>双亲委派模型的第二次“破坏”是由这个模型自身的缺陷所导致的，双亲委派很好的解决了各个类加载器的基础类统一问题，基础类之所以“基础”，是因为他们总被用户代码所调用，但是如果基础类又要重新调用用户代码，那咋办？
比如说JNDI是java的标准服务，它的代码是由启动类加载器进行加载的，但是jndi的作用就是进行资源的集中管理和查找，它需要调用由开发人员开发在classpath下的类代码，但是启动类加载器不会进行加载。
所以引入线程上下类加载器，通过java.lang.Thread类的setContextClassLoader()方法进行设置。如果创建线程是还未设置，它会从父线程继承一个，如果在应用程序全局范围内没有设置，那么这个线程上下类加载器就是应用程序类加载器。那么这样JNDI服务使用这个线程上下类加载器去加载所需的spi代码，也就是父类加载器请求子类加载器去完成类加载的动作，这个实际是打通了双亲委派的逆向层次结构。</li> <li></li></ul> <h2 id="列举一些你知道的打破双亲委派机制的例子，为什么要打破"><a href="#列举一些你知道的打破双亲委派机制的例子，为什么要打破" class="header-anchor">#</a> 列举一些你知道的打破双亲委派机制的例子，为什么要打破</h2> <ul><li><p>JNDI 通过引入线程上下文类加载器，可以在 Thread.setContextClassLoader 方法设置，默认是应用程序类加载器，来加载 SPI 的代码。有了线程上下文类加载器，就可以完成父类加载器请求子类加载器完成类加载的行为。打破的原因，是为了 JNDI 服务的类加载器是启动器类加载，为了完成高级类加载器请求子类加载器（即上文中的线程上下文加载器）加载类。</p></li> <li><p>Tomcat，应用的类加载器优先自行加载应用目录下的 class，并不是先委派给父加载器，加载不了才委派给父加载器。</p> <p>tomcat之所以造了一堆自己的classloader，大致是出于下面三类目的：</p> <ul><li><p>对于各个 <code>webapp</code>中的 <code>class</code>和 <code>lib</code>，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源。</p></li> <li><p>与 <code>jvm</code>一样的安全性问题。使用单独的 <code>classloader</code>去装载 <code>tomcat</code>自身的类库，以免其他恶意或无意的破坏；</p></li> <li><p>热部署。</p></li></ul></li> <li><p>JDK 9，Extension ClassLoader 被 Platform ClassLoader 取代，当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。打破的原因，是为了添加模块化的特性。</p></li></ul> <h2 id="获取classloader的方法"><a href="#获取classloader的方法" class="header-anchor">#</a> 获取classloader的方法</h2> <ul><li><p>获取当前的ClassLoader</p> <div class="language-java extra-class"><pre class="language-java"><code>clazz<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>获取当前线程的上下文的ClassLoader</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>获取系统的ClassLoader</p> <div class="language-java extra-class"><pre class="language-java"><code> <span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>获取调用者的ClassLoader</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">DriverManager</span><span class="token punctuation">.</span>getCallerClassLoader
</code></pre></div></li></ul> <h2 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="header-anchor">#</a> 类的主动使用和被动使用</h2> <p>Java程序对类的使用方式分为：主动使用和被动使用</p> <p>主动使用分为七种：</p> <ul><li><p>创建类的实例</p></li> <li><p>调用某个类或者接口的静态变量</p></li> <li><p>调用类的静态方法</p></li> <li><p>反射</p></li> <li><p>初始化一个类的子类</p></li> <li><p>java虚拟机启动时被标明为启动类的类</p></li> <li><p>jdk7开始提供动态语言支持</p></li></ul> <h2 id="创建对象的方式"><a href="#创建对象的方式" class="header-anchor">#</a> <strong>创建对象的方式</strong></h2> <p>1.使用new关键字实例化一个对象。</p> <p>2.通过反射机制动态创建对象。</p> <p>3.调用Object类的对象克隆clone()方法创建对象。</p> <p>4.使用反序列化方式创建对象。</p> <h2 id="full-gc的触发条件"><a href="#full-gc的触发条件" class="header-anchor">#</a> Full GC的触发条件</h2> <p>对于 Minor GC，其触发条件比较简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 触发 条件相对复杂，有以下情况会发生 full GC：</p> <ul><li><p><strong>调用 System.gc()</strong></p> <p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p></li> <li><p><strong>老年代空间不足</strong></p> <p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 参数 调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 - XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间</p></li> <li><p>空间分配担保失败</p> <p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC</p></li> <li><p>方法区空间不足</p></li></ul> <h2 id="为什么要将永久代-permgen-替换为元空间-metaspace"><a href="#为什么要将永久代-permgen-替换为元空间-metaspace" class="header-anchor">#</a> 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace)</h2> <p>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p> <h2 id="字符串常量池为什么要调整"><a href="#字符串常量池为什么要调整" class="header-anchor">#</a> 字符串常量池为什么要调整</h2> <p>jdk7 中将 StringTable 放到了堆空间中。因为永久代的回收效率很低，在 full gc 的时候才会触发。而 full gc 是老年代的空间不足、永久代不足时才会触发。 这就导致 StringTable 回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p> <h2 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="header-anchor">#</a> 内存溢出与内存泄露</h2> <h3 id="内存溢出（oom）"><a href="#内存溢出（oom）" class="header-anchor">#</a> 内存溢出（OOM）</h3> <p>javadoc 中对 <code>OutOfMemoryError</code>的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</p> <p>首先说没有空闲内存的情况：说明 Java 虚拟机的堆内存不够。原因有二：</p> <ol><li>. Java 虚拟机的堆内存设置不够。</li> <li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</li></ol> <h3 id="内存泄漏（memory-leak）"><a href="#内存泄漏（memory-leak）" class="header-anchor">#</a> 内存泄漏（Memory Leak）</h3> <p>只有对象不会再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄漏。</p> <p>举例</p> <ol><li><p>单例模式</p> <p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p></li> <li><p>一些提供 close 的资源未关闭导致内存泄漏</p> <p>数据库连接（dataSourse.getConnection() ），网络连接（socket）和 io 连接必须手动 close，否则是不能被回收的</p></li></ol> <h2 id="变量在内存中的位置"><a href="#变量在内存中的位置" class="header-anchor">#</a> 变量在内存中的位置</h2> <p>变量分为：</p> <ul><li><p>局部变量（方法体中声明）</p> <p>存储在栈内存</p></li> <li><p>成员变量（方法体外声明）</p> <ul><li>静态变量（1.6在方法区 1.7后面在堆）</li> <li>实例变量（存储在堆内存）</li></ul></li></ul> <h2 id="常用的-jvm-调优的参数都有哪些"><a href="#常用的-jvm-调优的参数都有哪些" class="header-anchor">#</a> 常用的 JVM 调优的参数都有哪些</h2> <p><strong>jps</strong>：列出本机所有 Java 进程的<strong>进程号</strong>。</p> <p>常用参数如下：</p> <ul><li>-m 输出 main 方法的参数</li> <li>-l 输出完全的包名和应用主类名</li> <li>-v 输出 JVM 参数</li></ul> <div class="language-java extra-class"><pre class="language-java"><code>jps <span class="token operator">-</span>lvm
<span class="token comment">//output</span>
<span class="token comment">//4124 com.zzx.Application -</span>
javaagent<span class="token operator">:</span><span class="token class-name">E</span><span class="token operator">:</span>\IDEA2019\lib\idea_rt<span class="token punctuation">.</span>jar<span class="token operator">=</span><span class="token number">10291</span><span class="token operator">:</span><span class="token class-name">E</span><span class="token operator">:</span>\IDEA2019\bin <span class="token operator">-</span><span class="token class-name">Dfile</span><span class="token punctuation">.</span>encoding<span class="token operator">=</span>UTF<span class="token number">8</span>
</code></pre></div><p><strong>jstack</strong>：查看某个 Java 进程内的<strong>线程堆栈信息</strong>。使用参数 -l 可以打印额外的锁信息，发生死锁时可以使用 <code>jstack -l pid</code>观察锁持有情况</p> <div class="language-java extra-class"><pre class="language-java"><code>jstack <span class="token operator">-</span>l <span class="token number">4124</span> <span class="token operator">|</span> more
</code></pre></div><p>输出结果如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token string">&quot;http-nio-8001-exec-10&quot;</span> #<span class="token number">40</span> daemon prio<span class="token operator">=</span><span class="token number">5</span> os_prio<span class="token operator">=</span><span class="token number">0</span> tid<span class="token operator">=</span><span class="token number">0x000000002542f000</span>
nid<span class="token operator">=</span><span class="token number">0x4028</span> waiting on condition <span class="token punctuation">[</span><span class="token number">0x000000002cc9e000</span><span class="token punctuation">]</span>
java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token class-name">State</span><span class="token operator">:</span> WAITING <span class="token punctuation">(</span>parking<span class="token punctuation">)</span>
at sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span><span class="token class-name">Unsafe</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token class-name">Native</span> <span class="token class-name">Method</span><span class="token punctuation">)</span>
<span class="token operator">-</span> parking <span class="token keyword">to</span> wait <span class="token keyword">for</span> <span class="token generics"><span class="token punctuation">&lt;</span>0x000000077420d7e8<span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span>a
java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span><span class="token class-name">AbstractQueuedSynchronizer</span>$<span class="token class-name">ConditionObject</span><span class="token punctuation">)</span>
at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span><span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token class-name">LockSupport</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">175</span><span class="token punctuation">)</span>
at
java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span><span class="token class-name">AbstractQueuedSynchronizer</span>$<span class="token class-name">ConditionObject</span><span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token class-name">Abst</span>
ractQueuedSynchronizer<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">2039</span><span class="token punctuation">)</span>
at
java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span><span class="token class-name">LinkedBlockingQueue</span><span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token class-name">LinkedBlockingQueue</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">442</span><span class="token punctuation">)</span>
at org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>tomcat<span class="token punctuation">.</span>util<span class="token punctuation">.</span>threads<span class="token punctuation">.</span><span class="token class-name">TaskQueue</span><span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token class-name">TaskQueue</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">103</span><span class="token punctuation">)</span>
at org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>tomcat<span class="token punctuation">.</span>util<span class="token punctuation">.</span>threads<span class="token punctuation">.</span><span class="token class-name">TaskQueue</span><span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token class-name">TaskQueue</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">31</span><span class="token punctuation">)</span>
at
java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span><span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">.</span><span class="token function">getTask</span><span class="token punctuation">(</span><span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1074</span><span class="token punctuation">)</span>
at
java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span><span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">.</span><span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1134</span><span class="token punctuation">)</span>
at
java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span><span class="token class-name">ThreadPoolExecutor</span>$<span class="token class-name">Worker</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">624</span><span class="token punctuation">)</span>
at
org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>tomcat<span class="token punctuation">.</span>util<span class="token punctuation">.</span>threads<span class="token punctuation">.</span><span class="token class-name">TaskThread</span>$<span class="token class-name">WrappingRunnable</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">TaskThread</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">6</span>
<span class="token number">1</span><span class="token punctuation">)</span>
at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">748</span><span class="token punctuation">)</span>
<span class="token class-name">Locked</span> ownable synchronizers<span class="token operator">:</span>
<span class="token operator">-</span> <span class="token class-name">None</span>
</code></pre></div><p><strong>jstat</strong>：用于查看虚拟机各种<strong>运行状态信息</strong>（<strong>类装载、内存、垃圾收集等运行数据</strong>）。使用参数 -gcuitl 可以查看垃圾回收的统计信息。</p> <div class="language-java extra-class"><pre class="language-java"><code>jstat <span class="token operator">-</span>gcutil <span class="token number">4124</span>
S0 S1 <span class="token class-name">E</span> <span class="token class-name">O</span> <span class="token class-name">M</span> CCS YGC YGCT FGC FGCT GCT
<span class="token number">0.00</span> <span class="token number">0.00</span> <span class="token number">67.21</span> <span class="token number">19.20</span> <span class="token number">96.36</span> <span class="token number">94.96</span> <span class="token number">10</span> <span class="token number">0.084</span> <span class="token number">3</span> <span class="token number">0.191</span>
<span class="token number">0.275</span>
</code></pre></div><p><strong>jmap</strong>：查看<strong>堆内存快照</strong>。通过<code>jmap</code>命令可以获得运行中的堆内存的快照，从而可以对堆内存进行离线分析。</p> <p>查询进程4124的堆内存快照，输出结果如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token operator">&gt;</span>jmap <span class="token operator">-</span>heap <span class="token number">4124</span>
        <span class="token class-name">Attaching</span> <span class="token keyword">to</span> process <span class="token class-name">ID</span> <span class="token number">4124</span><span class="token punctuation">,</span> please wait<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token class-name">Debugger</span> attached successfully<span class="token punctuation">.</span>
        <span class="token class-name">Server</span> compiler detected<span class="token punctuation">.</span>
        JVM version is <span class="token number">25.221</span><span class="token operator">-</span>b11
        using thread<span class="token operator">-</span>local object allocation<span class="token punctuation">.</span>
        <span class="token class-name">Parallel</span> GC <span class="token keyword">with</span> <span class="token number">6</span> <span class="token function">thread</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
        <span class="token class-name">Heap</span> <span class="token class-name">Configuration</span><span class="token operator">:</span>
        <span class="token class-name">MinHeapFreeRatio</span> <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token class-name">MaxHeapFreeRatio</span> <span class="token operator">=</span> <span class="token number">100</span>
        <span class="token class-name">MaxHeapSize</span> <span class="token operator">=</span> <span class="token number">4238344192</span> <span class="token punctuation">(</span><span class="token number">4042.0</span>MB<span class="token punctuation">)</span>
        <span class="token class-name">NewSize</span> <span class="token operator">=</span> <span class="token number">88604672</span> <span class="token punctuation">(</span><span class="token number">84.5</span>MB<span class="token punctuation">)</span>
        <span class="token class-name">MaxNewSize</span> <span class="token operator">=</span> <span class="token number">1412431872</span> <span class="token punctuation">(</span><span class="token number">1347.0</span>MB<span class="token punctuation">)</span>
        <span class="token class-name">OldSize</span> <span class="token operator">=</span> <span class="token number">177733632</span> <span class="token punctuation">(</span><span class="token number">169.5</span>MB<span class="token punctuation">)</span>
        <span class="token class-name">NewRatio</span> <span class="token operator">=</span> <span class="token number">2</span>
        <span class="token class-name">SurvivorRatio</span> <span class="token operator">=</span> <span class="token number">8</span>
        <span class="token class-name">MetaspaceSize</span> <span class="token operator">=</span> <span class="token number">21807104</span> <span class="token punctuation">(</span><span class="token number">20.796875</span>MB<span class="token punctuation">)</span>
        <span class="token class-name">CompressedClassSpaceSize</span> <span class="token operator">=</span> <span class="token number">1073741824</span> <span class="token punctuation">(</span><span class="token number">1024.0</span>MB<span class="token punctuation">)</span>
        <span class="token class-name">MaxMetaspaceSize</span> <span class="token operator">=</span> <span class="token number">17592186044415</span> MB
        <span class="token class-name">G1HeapRegionSize</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0.0</span>MB<span class="token punctuation">)</span>
        <span class="token class-name">Heap</span> <span class="token class-name">Usage</span><span class="token operator">:</span>
          PS <span class="token class-name">Young</span> <span class="token class-name">Generation</span>
        <span class="token class-name">Eden</span> <span class="token class-name">Space</span><span class="token operator">:</span>
        capacity <span class="token operator">=</span> <span class="token number">327155712</span> <span class="token punctuation">(</span><span class="token number">312.0</span>MB<span class="token punctuation">)</span>
        used <span class="token operator">=</span> <span class="token number">223702392</span> <span class="token punctuation">(</span><span class="token number">213.33922576904297</span>MB<span class="token punctuation">)</span>
        free <span class="token operator">=</span> <span class="token number">103453320</span> <span class="token punctuation">(</span><span class="token number">98.66077423095703</span>MB<span class="token punctuation">)</span>
        <span class="token number">68.37795697725736</span><span class="token operator">%</span> used
        <span class="token class-name">From</span> <span class="token class-name">Space</span><span class="token operator">:</span>
        capacity <span class="token operator">=</span> <span class="token number">21495808</span> <span class="token punctuation">(</span><span class="token number">20.5</span>MB<span class="token punctuation">)</span>
        used <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0.0</span>MB<span class="token punctuation">)</span>
        free <span class="token operator">=</span> <span class="token number">21495808</span> <span class="token punctuation">(</span><span class="token number">20.5</span>MB<span class="token punctuation">)</span>
        <span class="token number">0.0</span><span class="token operator">%</span> used
        <span class="token class-name">To</span> <span class="token class-name">Space</span><span class="token operator">:</span>
        capacity <span class="token operator">=</span> <span class="token number">23068672</span> <span class="token punctuation">(</span><span class="token number">22.0</span>MB<span class="token punctuation">)</span>
        used <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0.0</span>MB<span class="token punctuation">)</span>
        free <span class="token operator">=</span> <span class="token number">23068672</span> <span class="token punctuation">(</span><span class="token number">22.0</span>MB<span class="token punctuation">)</span>
        <span class="token number">0.0</span><span class="token operator">%</span> used
        PS <span class="token class-name">Old</span> <span class="token class-name">Generation</span>
        capacity <span class="token operator">=</span> <span class="token number">217579520</span> <span class="token punctuation">(</span><span class="token number">207.5</span>MB<span class="token punctuation">)</span>
        used <span class="token operator">=</span> <span class="token number">41781472</span> <span class="token punctuation">(</span><span class="token number">39.845916748046875</span>MB<span class="token punctuation">)</span>
        free <span class="token operator">=</span> <span class="token number">175798048</span> <span class="token punctuation">(</span><span class="token number">167.65408325195312</span>MB<span class="token punctuation">)</span>
        <span class="token number">19.20285144484187</span><span class="token operator">%</span> used
        <span class="token number">27776</span> interned <span class="token class-name">Strings</span> occupying <span class="token number">3262336</span> bytes<span class="token punctuation">.</span>

</code></pre></div><h2 id="cpu100"><a href="#cpu100" class="header-anchor">#</a> CPU100%</h2> <p>1.查出消耗cpu最高的进程PID：执行top -c命令，列出进程运行信息表，再按下P,进程就会按照cpu使用率从高到低排序。记录下CPU使用率最高的PID。</p> <p>2.根据第一步所得的PID查出消耗cpu最高的线程号，执行命令：top -Hp 进程号（PID）;列出该进程下的线程运行信息列表，再按下P,线程就会按照cpu使用率从高到低排序，记录下哪个线程的CPU使用率最高。</p> <p>3.根据第二步骤得到的线程号查出对应的java线程，进行处理，先把这个线程号转为十六进制，执行命令：jstack -l 线程号&gt; ./线程号.stack，然后执行，grep命令，查找该线程号的日志信息：cat 线程号.stack |grep 'bda' -C 8，这样问题一般都可以定位到了。</p> <h2 id="频繁full-gc"><a href="#频繁full-gc" class="header-anchor">#</a> 频繁Full GC</h2> <p>full gc 触发条件是 老年代空间不足， 所以追因的方向就是导致 老年代空间不足的原因：
大量对象频繁进入老年代 + 老年代空间释放不掉</p> <ol><li>系统并发高、执行耗时过长，或者数据量过大，导致 young gc频繁，且gc后存活对象太多，但是survivor 区存放不下（太小 或 动态年龄判断） 导致对象快速进入老年代 老年代迅速堆满</li> <li>发程序一次性加载过多对象到内存 （大对象），导致频繁有大对象进入老年代 造成full gc</li> <li>存在内存溢出的情况，老年代驻留了大量释放不掉的对象， 只要有一点点对象进入老年代 就达到 full gc的水位了</li> <li>元数据区加载了太多类 ，满了 也会发生 full gc</li> <li>堆外内存 direct buffer memory 使用不当导致</li></ol> <h3 id="定位思路"><a href="#定位思路" class="header-anchor">#</a> 定位思路</h3> <p>如果有监控，那么通过图形能比较直观、快速的了解gc情况；
如果没有监控，那么只能看gc日志或jstat来分析 这是基本技能一定要熟练</p> <ol><li>观察年轻代 gc的情况，多久执行一次、每次gc后存活对象有多少 survivor区多大
存活对象比较多 超过survivor区大小或触发动态年龄判断 =&gt; 调整内存分配比例</li> <li>观察老年代的内存情况 水位情况，多久执行一次、执行耗时多少、回收掉多少内存
如果在持续的上涨，而且full gc后回收效果不好，那么很有可能是内存溢出了 =&gt; dump 排查具体是什么玩意</li> <li>如果年轻代和老年代的内存都比较低，而且频率低 那么又可能是元数据区加载太多东西了</li> <li>其实如果是自己负责的系统，可能要看是不是发版改了什么配置、代码</li></ol> <h2 id="线上故障排查"><a href="#线上故障排查" class="header-anchor">#</a> 线上故障排查</h2> <h3 id="_1、硬件故障排查"><a href="#_1、硬件故障排查" class="header-anchor">#</a> 1、硬件故障排查</h3> <p>如果一个实例发生了问题，根据情况选择，要不要着急去重启。如果出现的CPU、内存飙高或者日志里出现了OOM异常</p> <p><strong>第一步是隔离</strong>，第二步是<strong>保留现场</strong>，第三步才是<strong>问题排查</strong>。</p> <p><strong>隔离</strong></p> <p>就是把你的这台机器从请求列表里摘除，比如把 nginx 相关的权重设成零。</p> <p><strong>现场保留</strong></p> <p><strong>瞬时态和历史态</strong></p> <p><img src="https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209121109366.jpeg" alt="img"></p> <p>查看比如 CPU、系统内存等，通过历史状态可以体现一个趋势性问题，而这些信息的获取一般依靠监控系统的协作。</p> <p><strong>保留信息</strong></p> <p>（1）<strong>系统当前网络连接</strong></p> <div class="language- extra-class"><pre class="language-text"><code>ss -antp &gt; $DUMP_DIR/ss.dump 2&gt;&amp;1
</code></pre></div><p>使用 ss 命令而不是 netstat 的原因，是因为 netstat 在网络连接非常多的情况下，执行非常缓慢。</p> <p>后续的处理，可通过查看各种网络连接状态的梳理，来排查 TIME_WAIT 或者 CLOSE_WAIT，或者其他连接过高的问题，非常有用。</p> <p>（2）<strong>网络状态统计</strong></p> <div class="language-java extra-class"><pre class="language-java"><code>netstat <span class="token operator">-</span>s <span class="token operator">&gt;</span> $DUMP_DIR<span class="token operator">/</span>netstat<span class="token operator">-</span>s<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>
</code></pre></div><p>它能够按照各个协议进行统计输出，对把握当时整个网络状态，有非常大的作用。</p> <div class="language-java extra-class"><pre class="language-java"><code>sar <span class="token operator">-</span>n DEV <span class="token number">1</span> <span class="token number">2</span> <span class="token operator">&gt;</span> $DUMP_DIR<span class="token operator">/</span>sar<span class="token operator">-</span>traffic<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>
</code></pre></div><p>在一些速度非常高的模块上，比如 Redis、Kafka，就经常发生跑满网卡的情况。表现形式就是网络通信非常缓慢。</p> <p>（3）<strong>进程资源</strong></p> <div class="language-java extra-class"><pre class="language-java"><code>lsof <span class="token operator">-</span>p $PID <span class="token operator">&gt;</span> $DUMP_DIR<span class="token operator">/</span>lsof<span class="token operator">-</span>$PID<span class="token punctuation">.</span>dump
</code></pre></div><p>通过查看进程，能看到打开了哪些文件，可以以进程的维度来查看整个资源的使用情况，包括每条网络连接、每个打开的文件句柄。同时，也可以很容易的看到连接到了哪些服务器、使用了哪些资源。这个命令在资源非常多的情况下，输出稍慢，请耐心等待。</p> <p>（4）<strong>CPU 资源</strong></p> <div class="language- extra-class"><pre class="language-text"><code>mpstat &gt; $DUMP_DIR/mpstat.dump 2&gt;&amp;1
vmstat 1 3 &gt; $DUMP_DIR/vmstat.dump 2&gt;&amp;1
sar -p ALL  &gt; $DUMP_DIR/sar-cpu.dump  2&gt;&amp;1
uptime &gt; $DUMP_DIR/uptime.dump 2&gt;&amp;1
</code></pre></div><p>主要用于输出当前系统的 CPU 和负载，便于事后排查。</p> <p>（5）<strong>I/O 资源</strong></p> <div class="language-java extra-class"><pre class="language-java"><code>iostat <span class="token operator">-</span>x <span class="token operator">&gt;</span> $DUMP_DIR<span class="token operator">/</span>iostat<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>
</code></pre></div><p>一般，以计算为主的服务节点，I/O 资源会比较正常，但有时也会发生问题，比如<strong>日志输出过多，或者磁盘问题</strong>等。此命令可以输出每块磁盘的基本性能信息，用来排查 I/O 问题。在第 8 课时介绍的 GC 日志分磁盘问题，就可以使用这个命令去发现。</p> <p>（6）<strong>内存问题</strong></p> <div class="language-java extra-class"><pre class="language-java"><code>free <span class="token operator">-</span>h <span class="token operator">&gt;</span> $DUMP_DIR<span class="token operator">/</span>free<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>
</code></pre></div><p>free 命令能够大体展现操作系统的内存概况，这是故障排查中一个非常重要的点，比如 SWAP 影响了 GC，SLAB 区挤占了 JVM 的内存。</p> <p>（7）<strong>其他全局</strong></p> <div class="language-java extra-class"><pre class="language-java"><code>ps <span class="token operator">-</span>ef <span class="token operator">&gt;</span> $DUMP_DIR<span class="token operator">/</span>ps<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>
dmesg <span class="token operator">&gt;</span> $DUMP_DIR<span class="token operator">/</span>dmesg<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>
sysctl <span class="token operator">-</span>a <span class="token operator">&gt;</span> $DUMP_DIR<span class="token operator">/</span>sysctl<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>
</code></pre></div><p>dmesg 是许多静悄悄死掉的服务留下的最后一点线索。当然，ps 作为执行频率最高的一个命令，由于内核的配置参数，会对系统和 JVM 产生影响，所以我们也输出了一份。</p> <p>（8）<strong>进程快照</strong>，最后的遗言（jinfo）</p> <div class="language-java extra-class"><pre class="language-java"><code>$<span class="token punctuation">{</span>JDK_BIN<span class="token punctuation">}</span>jinfo $PID <span class="token operator">&gt;</span> $DUMP_DIR<span class="token operator">/</span>jinfo<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>
</code></pre></div><p>此命令将输出 Java 的基本进程信息，包括<strong>环境变量和参数配置</strong>，可以查看是否因为一些错误的配置造成了 JVM 问题。</p> <p><strong>（9）dump 堆信息</strong></p> <div class="language-java extra-class"><pre class="language-java"><code>$<span class="token punctuation">{</span>JDK_BIN<span class="token punctuation">}</span>jstat <span class="token operator">-</span>gcutil $PID <span class="token operator">&gt;</span> $DUMP_DIR<span class="token operator">/</span>jstat<span class="token operator">-</span>gcutil<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>
$<span class="token punctuation">{</span>JDK_BIN<span class="token punctuation">}</span>jstat <span class="token operator">-</span>gccapacity $PID <span class="token operator">&gt;</span> $DUMP_DIR<span class="token operator">/</span>jstat<span class="token operator">-</span>gccapacity<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>
</code></pre></div><p>jstat 将输出当前的 gc 信息。一般，基本能大体看出一个端倪，如果不能，可将借助 jmap 来进行分析。</p> <p><strong>（10）堆信息</strong></p> <div class="language-java extra-class"><pre class="language-java"><code>$<span class="token punctuation">{</span>JDK_BIN<span class="token punctuation">}</span>jmap $PID <span class="token operator">&gt;</span> $DUMP_DIR<span class="token operator">/</span>jmap<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>
$<span class="token punctuation">{</span>JDK_BIN<span class="token punctuation">}</span>jmap <span class="token operator">-</span>heap $PID <span class="token operator">&gt;</span> $DUMP_DIR<span class="token operator">/</span>jmap<span class="token operator">-</span>heap<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>
$<span class="token punctuation">{</span>JDK_BIN<span class="token punctuation">}</span>jmap <span class="token operator">-</span>histo $PID <span class="token operator">&gt;</span> $DUMP_DIR<span class="token operator">/</span>jmap<span class="token operator">-</span>histo<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>
$<span class="token punctuation">{</span>JDK_BIN<span class="token punctuation">}</span>jmap <span class="token operator">-</span>dump<span class="token operator">:</span>format<span class="token operator">=</span>b<span class="token punctuation">,</span>file<span class="token operator">=</span>$DUMP_DIR<span class="token operator">/</span>heap<span class="token punctuation">.</span>bin $PID <span class="token operator">&gt;</span> <span class="token operator">/</span>dev<span class="token operator">/</span><span class="token keyword">null</span>  <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>
</code></pre></div><p>jmap 将会得到当前 Java 进程的 dump 信息。如上所示，其实最有用的就是第 4 个命令，但是前面三个能够让你初步对系统概况进行大体判断。因为，第 4 个命令产生的文件，一般都非常的大。而且，需要下载下来，导入 MAT 这样的工具进行深入分析，才能获取结果。这是分析内存泄漏一个必经的过程。</p> <p><strong>（11）JVM 执行栈</strong></p> <div class="language-java extra-class"><pre class="language-java"><code>$<span class="token punctuation">{</span>JDK_BIN<span class="token punctuation">}</span>jstack $PID <span class="token operator">&gt;</span> $DUMP_DIR<span class="token operator">/</span>jstack<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>
</code></pre></div><p>jstack 将会获取当时的执行栈。一般会多次取值，我们这里取一次即可。这些信息非常有用，能够还原 Java 进程中的线程情况。</p> <div class="language-java extra-class"><pre class="language-java"><code>top <span class="token operator">-</span><span class="token class-name">Hp</span> $PID <span class="token operator">-</span>b <span class="token operator">-</span>n <span class="token number">1</span> <span class="token operator">-</span>c <span class="token operator">&gt;</span>  $DUMP_DIR<span class="token operator">/</span>top<span class="token operator">-</span>$PID<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token number">1</span>
</code></pre></div><p>为了能够得到更加精细的信息，我们使用 top 命令，来获取进程中所有线程的 CPU 信息，这样，就可以看到资源到底耗费在什么地方了。</p> <p><strong>（12）高级替补</strong></p> <div class="language-java extra-class"><pre class="language-java"><code>kill <span class="token operator">-</span><span class="token number">3</span> $PID
</code></pre></div><p>有时候，jstack 并不能够运行，有很多原因，比如 Java 进程几乎不响应了等之类的情况。我们会尝试向进程发送 kill -3 信号，这个信号将会打印 jstack 的 trace 信息到日志文件中，是 jstack 的一个替补方案。</p> <div class="language-java extra-class"><pre class="language-java"><code>gcore <span class="token operator">-</span>o $DUMP_DIR<span class="token operator">/</span>core $PID
</code></pre></div><p>对于 jmap 无法执行的问题，也有替补，那就是 GDB 组件中的 gcore，将会生成一个 core 文件。我们可以使用如下的命令去生成 dump：</p> <div class="language-java extra-class"><pre class="language-java"><code>$<span class="token punctuation">{</span>JDK_BIN<span class="token punctuation">}</span>jhsdb jmap <span class="token operator">--</span>exe $<span class="token punctuation">{</span>JDK<span class="token punctuation">}</span>java  <span class="token operator">--</span>core $DUMP_DIR<span class="token operator">/</span>core <span class="token operator">--</span>binaryheap
</code></pre></div><ol><li><strong>内存泄漏的现象</strong></li></ol> <p>稍微提一下 jmap 命令，它在 9 版本里被干掉了，取而代之的是 jhsdb，你可以像下面的命令一样使用。</p> <div class="language-java extra-class"><pre class="language-java"><code>jhsdb jmap  <span class="token operator">--</span>heap <span class="token operator">--</span>pid  <span class="token number">37340</span>
jhsdb jmap  <span class="token operator">--</span>pid  <span class="token number">37288</span>
jhsdb jmap  <span class="token operator">--</span>histo <span class="token operator">--</span>pid  <span class="token number">37340</span>
jhsdb jmap  <span class="token operator">--</span>binaryheap <span class="token operator">--</span>pid  <span class="token number">37340</span>
</code></pre></div><p>一般内存溢出，表现形式就是 Old 区的占用持续上升，即使经过了多轮 GC 也没有明显改善。比如ThreadLocal里面的GC Roots，内存泄漏的根本就是，这些对象并没有切断和 GC Roots 的关系，可通过一些工具，能够看到它们的联系。</p> <h3 id="_2、报表异常-jvm调优"><a href="#_2、报表异常-jvm调优" class="header-anchor">#</a> 2、报表异常 | JVM调优</h3> <p>有一个报表系统，频繁发生内存溢出，在高峰期间使用时，还会频繁的发生拒绝服务，由于大多数使用者是管理员角色，所以很快就反馈到研发这里。</p> <p>业务场景是由于有些结果集的字段不是太全，因此需要对结果集合进行循环，并通过 HttpClient 调用其他服务的接口进行数据填充。使用 Guava 做了 JVM 内缓存，但是响应时间依然很长。</p> <p>初步排查，JVM 的资源太少。接口 A 每次进行报表计算时，都要涉及几百兆的内存，而且在内存里驻留很长时间，有些计算又非常耗 CPU，特别的“吃”资源。而我们分配给 JVM 的内存只有 3 GB，在多人访问这些接口的时候，内存就不够用了，进而发生了 OOM。在这种情况下，没办法，只有升级机器。把机器配置升级到 4C8G，给 JVM 分配 6GB 的内存，这样 OOM 问题就消失了。但随之而来的是频繁的 GC 问题和超长的 GC 时间，平均 GC 时间竟然有 5 秒多。</p> <p>进一步，由于报表系统和高并发系统不太一样，它的对象，存活时长大得多，并不能仅仅通过增加年轻代来解决；而且，如果增加了年轻代，那么必然减少了老年代的大小，由于 CMS 的碎片和浮动垃圾问题，我们可用的空间就更少了。虽然服务能够满足目前的需求，但还有一些不太确定的风险。</p> <p>第一，了解到程序中有很多缓存数据和静态统计数据，为了减少 MinorGC 的次数，通过分析 GC 日志打印的对象年龄分布，把 MaxTenuringThreshold 参数调整到了 3（特殊场景特殊的配置）。这个参数是让年轻代的这些对象，赶紧回到老年代去，不要老呆在年轻代里。</p> <p>第二，我们的 GC 时间比较长，就一块开了参数 CMSScavengeBeforeRemark，使得在 CMS remark 前，先执行一次 Minor GC 将新生代清掉。同时配合上个参数，其效果还是比较好的，一方面，对象很快晋升到了老年代，另一方面，年轻代的对象在这种情况下是有限的，在整个 MajorGC 中占的时间也有限。</p> <p>第三，由于缓存的使用，有大量的弱引用，拿一次长达 10 秒的 GC 来说。我们发现在 GC 日志里，处理 weak refs 的时间较长，达到了 4.5 秒。这里可以加入参数 ParallelRefProcEnabled 来并行处理Reference，以加快处理速度，缩短耗时。</p> <p>优化之后，效果不错，但并不是特别明显。经过评估，针对高峰时期的情况进行调研，我们决定再次提升机器性能，改用 8core16g 的机器。但是，这带来另外一个问题。</p> <p><strong>高性能的机器带来了非常大的服务吞吐量</strong>，通过 jstat 进行监控，能够看到年轻代的分配速率明显提高，但随之而来的 MinorGC 时长却变的不可控，有时候会超过 1 秒。累积的请求造成了更加严重的后果。</p> <p>这是由于堆空间明显加大造成的回收时间加长。为了获取较小的停顿时间，我们在堆上<strong>改用了 G1 垃圾回收器</strong>，把它的目标设定在 200ms。G1 是一款非常优秀的垃圾收集器，不仅适合堆内存大的应用，同时也简化了调优的工作。通过主要的参数初始和最大堆空间、以及最大容忍的 GC 暂停目标，就能得到不错的性能。修改之后，虽然 GC 更加频繁了一些，但是停顿时间都比较小，应用的运行较为平滑。</p> <p>到目前为止，也只是勉强顶住了已有的业务，但是，这时候领导层面又发力，<strong>要求报表系统可以支持未来两年业务10到100倍的增长</strong>，并保持其可用性，但是这个“千疮百孔”的报表系统，稍微一压测，就宕机，那如何应对十倍百倍的压力呢 ? 硬件即使可以做到动态扩容，但是毕竟也有极限。</p> <p>使用 MAT 分析堆快照，发现很多地方可以通过代码优化，那些占用内存特别多的对象：</p> <p>1、select * 全量排查，只允许获取必须的数据</p> <p>2、报表系统中cache实际的命中率并不高，将Guava 的 Cache 引用级别改成弱引用（WeakKeys）</p> <p>3、限制报表导入文件大小，同时拆分用户超大范围查询导出请求。</p> <p>每一步操作都使得JVM使用变得更加可用，一系列优化以后，机器相同压测数据性能提升了数倍。</p> <h3 id="_3、大屏异常-juc调优"><a href="#_3、大屏异常-juc调优" class="header-anchor">#</a> 3、大屏异常 | JUC调优</h3> <p>有些数据需要使用 HttpClient 来获取进行补全。提供数据的服务提供商有的响应时间可能会很长，也有可能会造成服务整体的阻塞。</p> <p><img src="https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209121109523.jpeg" alt="img"></p> <p>接口 A 通过 HttpClient 访问服务 2，响应 100ms 后返回；接口 B 访问服务 3，耗时 2 秒。HttpClient 本身是有一个最大连接数限制的，如果服务 3 迟迟不返回，就会造成 HttpClient 的连接数达到上限，<strong>概括来讲，就是同一服务，由于一个耗时非常长的接口，进而引起了整体的服务不可用</strong></p> <p>这个时候，通过 jstack 打印栈信息，会发现大多数竟然阻塞在了接口 A 上，而不是耗时更长的接口 B，这个现象起初十分具有迷惑性，不过经过分析后，我们猜想其实是因为接口 A 的速度比较快，在问题发生点进入了更多的请求，它们全部都阻塞住的同时被打印出来了。</p> <p>为了验证这个问题，我搭建了一个demo 工程，模拟了两个使用同一个 HttpClient 的接口。fast 接口用来访问百度，很快就能返回；slow 接口访问谷歌，由于众所周知的原因，会阻塞直到超时，大约 10 s。 利用ab对两个接口进行压测，同时使用 jstack 工具 dump 堆栈。首先使用 jps 命令找到进程号，然后把结果重定向到文件（可以参考 10271.jstack 文件）。</p> <p>过滤一下 nio 关键字，可以查看 tomcat 相关的线程，足足有 200 个，这和 Spring Boot 默认的 maxThreads 个数不谋而合。更要命的是，有大多数线程，都处于 BLOCKED 状态，说明线程等待资源超时。通过grep fast | wc -l 分析，确实200个中有150个都是blocked的fast的进程。</p> <p>问题找到了，解决方式就顺利成章了。</p> <p>1、fast和slow争抢连接资源，通过线程池限流或者熔断处理</p> <p>2、有时候slow的线程也不是一直slow，所以就得加入监控</p> <p>3、使用带countdownLaunch对线程的执行顺序逻辑进行控制</p> <h3 id="_4、接口延迟-swap调优"><a href="#_4、接口延迟-swap调优" class="header-anchor">#</a> 4、接口延迟 | SWAP调优</h3> <p>有一个关于服务的某个实例，经常发生服务卡顿。由于服务的并发量是比较高的，每多停顿 1 秒钟，几万用户的请求就会感到延迟。</p> <p>我们统计、类比了此服务其他实例的 CPU、内存、网络、I/O 资源，区别并不是很大，所以一度怀疑是机器硬件的问题。</p> <p>接下来我们对比了节点的 GC 日志，发现无论是 Minor GC，还是 Major GC，这个节点所花费的时间，都比其他实例长得多。</p> <p>通过仔细观察，我们发现在 GC 发生的时候，vmstat 的 si、so 飙升的非常严重，这和其他实例有着明显的不同。</p> <p>使用 free 命令再次确认，发现 SWAP 分区，使用的比例非常高，引起的具体原因是什么呢？</p> <p>更详细的操作系统内存分布，从 /proc/meminfo 文件中可以看到具体的逻辑内存块大小，有多达 40 项的内存信息，这些信息都可以通过遍历 /proc 目录的一些文件获取。我们注意到 slabtop 命令显示的有一些异常，dentry（目录高速缓冲）占用非常高。</p> <p>问题最终定位到是由于某个运维工程师删除日志时，定时执行了一句命令：</p> <p>find / | grep &quot;xxx.log&quot;</p> <p>他是想找一个叫做 要被删除 的日志文件，看看在哪台服务器上，结果，这些老服务器由于文件太多，扫描后这些文件信息都缓存到了 slab 区上。而服务器开了 swap，操作系统发现物理内存占满后，并没有立即释放 cache，导致每次 GC 都要和硬盘打一次交道。</p> <p><strong>解决方式就是关闭 SWAP 分区。</strong></p> <p>swap 是很多性能场景的万恶之源，建议禁用。在高并发 SWAP 绝对能让你体验到它魔鬼性的一面：进程倒是死不了了，但 GC 时间长的却让人无法忍受。</p> <h3 id="_5、内存溢出-cache调优"><a href="#_5、内存溢出-cache调优" class="header-anchor">#</a> 5、内存溢出 | Cache调优</h3> <blockquote><p>有一次线上遇到故障，重新启动后，使用 jstat 命令，发现 Old 区一直在增长。我使用 jmap 命令，导出了一份线上堆栈，然后使用 MAT 进行分析，通过对 GC Roots 的分析，发现了一个非常大的 HashMap 对象，这个原本是其他同事做缓存用的，但是做了一个无界缓存，没有设置超时时间或者 LRU 策略，在使用上又没有重写key类对象的hashcode和equals方法，对象无法取出也直接造成了堆内存占用一直上升，后来，将这个缓存改成 guava 的 Cache，并设置了弱引用，故障就消失了。</p> <p>关于文件处理器的应用，在读取或者写入一些文件之后，由于发生了一些异常，<strong>close 方法又没有放在 finally</strong> 块里面，造成了文件句柄的泄漏。由于文件处理十分频繁，产生了严重的内存泄漏问题。</p></blockquote> <p>内存溢出是一个结果，而<strong>内存泄漏</strong>是一个原因。内存溢出的原因有<strong>内存空间不足、配置错误</strong>等因素。一些错误的编程方式，不再被使用的对象、没有被回收、没有及时切断与 GC Roots 的联系，这就是内存泄漏。</p> <p>举个例子，有团队使用了 HashMap 做缓存，但是并没有设置超时时间或者 LRU 策略，造成了放入 Map 对象的数据越来越多，而产生了内存泄漏。</p> <p>再来看一个经常发生的内存泄漏的例子，也是由于 HashMap 产生的。代码如下，由于没有重写 Key 类的 hashCode 和 equals 方法，造成了放入 HashMap 的所有对象都无法被取出来，它们和外界失联了。所以下面的代码结果是 null。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//leak example</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util</span><span class="token punctuation">.</span><span class="token class-name">HashMap</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util</span><span class="token punctuation">.</span><span class="token class-name">Map</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMapLeakDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Key</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> title<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Key</span><span class="token punctuation">(</span><span class="token class-name">String</span> title<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Key</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Key</span><span class="token punctuation">(</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Key</span><span class="token punctuation">(</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Integer</span> integer <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Key</span><span class="token punctuation">(</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>即使提供了 equals 方法和 hashCode 方法，也要非常小心，尽量避免使用自定义的对象作为 Key。</p> <p>再看一个例子，关于文件处理器的应用，在读取或者写入一些文件之后，由于发生了一些异常，<strong>close 方法又没有放在 finally</strong> 块里面，造成了文件句柄的泄漏。由于文件处理十分频繁，产生了严重的内存泄漏问题。</p> <h3 id="_6、cpu飙高-死循环"><a href="#_6、cpu飙高-死循环" class="header-anchor">#</a> 6、CPU飙高 | 死循环</h3> <p>我们有个线上应用，单节点在运行一段时间后，CPU 的使用会飙升，一旦飙升，一般怀疑某个业务逻辑的计算量太大，或者是触发了死循环（比如著名的 HashMap 高并发引起的死循环），但排查到最后其实是 GC 的问题。</p> <p>（1）使用 top 命令，查找到使用 CPU 最多的某个进程，记录它的 pid。使用 Shift + P 快捷键可以按 CPU 的使用率进行排序。</p> <div class="language-java extra-class"><pre class="language-java"><code>top
</code></pre></div><p>（2）再次使用 top 命令，加 -H 参数，查看某个进程中使用 CPU 最多的某个线程，记录线程的 ID。</p> <div class="language-java extra-class"><pre class="language-java"><code>top <span class="token operator">-</span><span class="token class-name">Hp</span> $pid
</code></pre></div><p>（3）使用 printf 函数，将十进制的 tid 转化成十六进制。</p> <div class="language-java extra-class"><pre class="language-java"><code>printf <span class="token operator">%</span>x $tid
</code></pre></div><p>（4）使用 jstack 命令，查看 Java 进程的线程栈。</p> <div class="language-java extra-class"><pre class="language-java"><code>jstack $pid <span class="token operator">&gt;</span>$pid<span class="token punctuation">.</span>log
</code></pre></div><p>（5）使用 less 命令查看生成的文件，并查找刚才转化的十六进制 tid，找到发生问题的线程上下文。</p> <div class="language-java extra-class"><pre class="language-java"><code>less $pid<span class="token punctuation">.</span>log
</code></pre></div><p>我们在 jstack 日志搜关键字DEAD，以及中找到了 CPU 使用最多的几个线程id。</p> <p>可以看到问题发生的根源，是我们的堆已经满了，但是又没有发生 OOM，于是 GC 进程就一直在那里回收，回收的效果又非常一般，造成 CPU 升高应用假死。接下来的具体问题排查，就需要把内存 dump 一份下来，使用 MAT 等工具分析具体原因了。</p> <h2 id="如何解决oom"><a href="#如何解决oom" class="header-anchor">#</a> 如何解决OOM</h2> <ol><li>要解决 OOM 异常或 heap space 的异常，一般的手段是首先通过内存映像分析工具（如 Eclipse Memory Analyzer）对 dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要 的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</li> <li>如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与 GCRoots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及 GCRoots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li> <li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆 参数（ -Xmx 与 -Xms ），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象 生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li></ol> <h2 id="为什么要有survivor区？"><a href="#为什么要有survivor区？" class="header-anchor">#</a> 为什么要有survivor区？</h2> <ul><li><p>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC。</p></li> <li><p>又因为老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多。频发的Full GC消耗的时间是非常可观的，这一点会影响大型程序的执行和响应速度</p></li> <li><p>因此Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</p></li></ul> <h2 id="为什么两个-survivor-区？"><a href="#为什么两个-survivor-区？" class="header-anchor">#</a> 为什么两个 survivor 区？</h2> <p>设置两个Survivor区+使用复制算法，最大的好处就是解决了碎片化。</p> <p>为什么一个Survivor区不行？刚新建的对象在Eden中，一旦Eden满了，触发一次Minor GC，Eden中的存活对象就会被移动到Survivor区。这样继续循环下去，极易导致内存碎片化。碎片化带来的风险是极大的，堆中没有足够大的连续内存空间。</p> <p>那么，顺理成章的，应该建立两块Survivor区，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）。S0和Eden被清空，然后下一轮S0与S1交换角色，如此循环往复。如果对象的复制次数达到16次，该对象就会被送到老年代中。</p> <p>那么，Survivor为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果Survivor区再细分下去，每一块的空间就会比较小，很容易导致Survivor区满，因此，我认为两块Survivor区是经过权衡之后的最佳方案。</p></div> <footer class="page-edit" style="display:none;"><!----> <!----></footer> <!----> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.3bc42cf8.js" defer></script><script src="/assets/js/3.0146fe10.js" defer></script><script src="/assets/js/1.760be874.js" defer></script><script src="/assets/js/18.04a1e384.js" defer></script>
  </body>
</html>
