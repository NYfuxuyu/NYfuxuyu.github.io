(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{501:function(_,t,v){"use strict";v.r(t);var s=v(4),e=Object(s.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("blockquote",[v("p",[_._v("计算机网络")])]),_._v(" "),v("h2",{attrs:{id:"_1-计算机网络的各层协议及作用？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-计算机网络的各层协议及作用？"}},[_._v("#")]),_._v(" 1. 计算机网络的各层协议及作用？")]),_._v(" "),v("p",[_._v("计算机网络体系可以大致分为一下三种，OSI七层模型、TCP/IP四层模型和五层模型。")]),_._v(" "),v("ul",[v("li",[_._v("OSI七层模型：大而全，但是比较复杂、而且是先有了理论模型，没有实际应用。")]),_._v(" "),v("li",[_._v("TCP/IP四层模型：是由实际应用发展总结出来的，从实质上讲，TCP/IP只有最上面三层，最下面一层没有什么具体内容，TCP/IP参考模型没有真正描述这一层的实现。")]),_._v(" "),v("li",[_._v("五层模型：五层模型只出现在计算机网络教学过程中，这是对七层模型和四层模型的一个折中，既简洁又能将概念阐述清楚。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://typora-fxy.oss-cn-hangzhou.aliyuncs.com/img/image-20220927205643392.png",alt:"image-20220927205643392"}})]),_._v(" "),v("p",[_._v("七层网络体系结构各层的主要功能：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("应用层：为应用程序提供交互服务。在互联网中的应用层协议很多，如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等。")])]),_._v(" "),v("li",[v("p",[_._v("表示层：主要负责数据格式的转换，如加密解密、转换翻译、压缩解压缩等。")])]),_._v(" "),v("li",[v("p",[_._v("会话层：负责在网络中的两节点之间建立、维持和终止通信，如服务器验证用户登录便是由会话层完成的。")])]),_._v(" "),v("li",[v("p",[_._v("运输层：有时也译为传输层，向主机进程提供通用的数据传输服务。该层主要有以下两种协议：")]),_._v(" "),v("ul",[v("li",[_._v("TCP：提供面向连接的、可靠的数据传输服务；")]),_._v(" "),v("li",[_._v("UDP：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性。")])])]),_._v(" "),v("li",[v("p",[_._v("网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括IP协议。")])]),_._v(" "),v("li",[v("p",[_._v("数据链路层：数据链路层通常简称为链路层。将网络层传下来的IP数据包组装成帧，并再相邻节点的链路上传送帧。")])]),_._v(" "),v("li",[v("p",[_._v("物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异。")])])]),_._v(" "),v("h2",{attrs:{id:"_2-tcp报文格式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-tcp报文格式"}},[_._v("#")]),_._v(" 2. TCP报文格式")]),_._v(" "),v("h3",{attrs:{id:"_2-1-介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-介绍"}},[_._v("#")]),_._v(" 2.1 介绍")]),_._v(" "),v("p",[_._v("我们先来看看 TCP 头的格式，标注颜色的表示与本文关联比较大的字段，其他字段不做详细阐述。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202205021503087.png",alt:"TCP 头格式"}})]),_._v(" "),v("p",[v("strong",[_._v("序列号")]),_._v("：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。"),v("strong",[_._v("用来解决网络包乱序问题。")])]),_._v(" "),v("p",[v("strong",[_._v("确认应答号")]),_._v("：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。"),v("strong",[_._v("用来解决丢包的问题。")])]),_._v(" "),v("p",[v("strong",[_._v("控制位：")])]),_._v(" "),v("ul",[v("li",[v("em",[_._v("ACK")]),_._v("：该位为 "),v("code",[_._v("1")]),_._v(" 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 "),v("code",[_._v("SYN")]),_._v(" 包之外该位必须设置为 "),v("code",[_._v("1")]),_._v(" 。")]),_._v(" "),v("li",[v("em",[_._v("RST")]),_._v("：该位为 "),v("code",[_._v("1")]),_._v(" 时，表示 TCP 连接中出现异常必须强制断开连接。")]),_._v(" "),v("li",[v("em",[_._v("SYN")]),_._v("：该位为 "),v("code",[_._v("1")]),_._v(" 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。")]),_._v(" "),v("li",[v("em",[_._v("FIN")]),_._v("：该位为 "),v("code",[_._v("1")]),_._v(" 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 "),v("code",[_._v("FIN")]),_._v(" 位为 1 的 TCP 段。")])]),_._v(" "),v("p",[_._v("TCP 是"),v("strong",[_._v("面向连接的、可靠的、基于字节流")]),_._v("的传输层通信协议。")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("面向连接")]),_._v("：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；")]),_._v(" "),v("li",[v("strong",[_._v("可靠的")]),_._v("：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；")]),_._v(" "),v("li",[v("strong",[_._v("字节流")]),_._v("：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。")])]),_._v(" "),v("h3",{attrs:{id:"_2-2-如何唯一确定一个-tcp-连接呢？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-如何唯一确定一个-tcp-连接呢？"}},[_._v("#")]),_._v(" 2.2 如何唯一确定一个 TCP 连接呢？")]),_._v(" "),v("p",[_._v("TCP 四元组可以唯一的确定一个连接，四元组包括如下：")]),_._v(" "),v("ul",[v("li",[_._v("源地址")]),_._v(" "),v("li",[_._v("源端口")]),_._v(" "),v("li",[_._v("目的地址")]),_._v(" "),v("li",[_._v("目的端口")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202205021505203.png",alt:"TCP 四元组"}})]),_._v(" "),v("h3",{attrs:{id:"_2-3-有一个-ip-的服务器监听了一个端口，它的-tcp-的最大连接数是多少？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-有一个-ip-的服务器监听了一个端口，它的-tcp-的最大连接数是多少？"}},[_._v("#")]),_._v(" 2.3 有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？")]),_._v(" "),v("p",[_._v("服务器通常固定在某个本地端口上监听，等待客户端的连接请求。")]),_._v(" "),v("p",[_._v("因此，客户端 IP 和 端口是可变的，其理论值计算公式如下:")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202205021505608.png",alt:"img"}})]),_._v(" "),v("h2",{attrs:{id:"_3-udp报文格式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-udp报文格式"}},[_._v("#")]),_._v(" 3. UDP报文格式")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/NYfuxuyu/typora-pic/main/202205021506473.png",alt:"UDP 头部格式"}})]),_._v(" "),v("ul",[v("li",[_._v("目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。")]),_._v(" "),v("li",[_._v("包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。")]),_._v(" "),v("li",[_._v("校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP包。")])]),_._v(" "),v("h2",{attrs:{id:"_4-tcp和udp的区别？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-tcp和udp的区别？"}},[_._v("#")]),_._v(" 4. TCP和UDP的区别？")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}}),_._v(" "),v("th",{staticStyle:{"text-align":"center"}},[_._v("UDP")]),_._v(" "),v("th",{staticStyle:{"text-align":"center"}},[_._v("TCP")])])]),_._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("是否连接")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("无连接")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("面向连接")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("是否可靠")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("不可靠传输，不使用流量控制和拥塞控制")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("可靠传输，使用流量控制和拥塞控制")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("是否有序")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("无序")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("有序，消息在传输过程中可能会乱序，TCP 会重新排序")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("传输速度")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("快")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("慢")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("连接对象个数")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("支持一对一，一对多，多对一和多对多交互通信")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("只能是一对一通信")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("传输方式")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("面向报文")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("面向字节流")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("首部开销")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("首部开销小，仅8字节")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("首部最小20字节，最大60字节")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("适用场景")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("适用于实时应用（IP电话、视频会议、直播等）")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("适用于要求可靠传输的应用，例如文件传输")])])])]),_._v(" "),v("p",[_._v("TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：")]),_._v(" "),v("ul",[v("li",[_._v("FTP文件传输")]),_._v(" "),v("li",[_._v("HTTP / HTTPS")])]),_._v(" "),v("p",[_._v("UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：")]),_._v(" "),v("ul",[v("li",[_._v("包总量较少的通信，如 DNS 、SNMP等")]),_._v(" "),v("li",[_._v("视频、音频等多媒体通信")]),_._v(" "),v("li",[_._v("广播通信")])]),_._v(" "),v("h2",{attrs:{id:"_5-tcp三次握手和四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-tcp三次握手和四次挥手"}},[_._v("#")]),_._v(" 5. TCP三次握手和四次挥手")]),_._v(" "),v("h3",{attrs:{id:"_5-1-三次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-三次握手"}},[_._v("#")]),_._v(" 5.1 三次握手")]),_._v(" "),v("p",[_._v("假设发送端为客户端，接收端为服务端。开始时客户端和服务端的状态都是 CLOSED 。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202205021421615.png",alt:"image-20220502142118556"}})]),_._v(" "),v("ol",[v("li",[_._v("第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，客户端向服务端发送的字段中包含标志位 "),v("code",[_._v("SYN=1")]),_._v(" ，序列号 "),v("code",[_._v("seq=x")]),_._v(" 。第一次握手前客户端的状态为"),v("code",[_._v("CLOSE")]),_._v(" ， 第一次握手后客户端的状态为 "),v("code",[_._v("SYN-SENT")]),_._v("。此时服务端的状态为 "),v("code",[_._v("LISTEN")]),_._v("。")]),_._v(" "),v("li",[_._v("第二次握手：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号"),v("code",[_._v("y")]),_._v("，然后给 客户端回复一段报文，其中包括标志位 "),v("code",[_._v("SYN=1")]),_._v(" ，"),v("code",[_._v("ACK=1")]),_._v(" ，序列号 "),v("code",[_._v("seq=y")]),_._v(" ，确认号 "),v("code",[_._v("ack=x+1")]),_._v(" 。第二次握手前服务端的状态为 "),v("code",[_._v("LISTEN")]),_._v(" ，第二次握手后服务端的状态为 "),v("code",[_._v("SYN-RCVD")]),_._v(" ，此时客户端的状态 为 "),v("code",[_._v("SYN-SENT")]),_._v(" 。（其中 "),v("code",[_._v("SYN=1")]),_._v(" 表示要和客户端建立一个连接， "),v("code",[_._v("ACK=1")]),_._v(" 表示确认序号有效）")]),_._v(" "),v("li",[_._v("第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位 "),v("code",[_._v("ACK=1")]),_._v(" ， 序列号 "),v("code",[_._v("seq=x+1")]),_._v("，确认号 "),v("code",[_._v("ack=y+1")]),_._v("。第三次握手前客户端的状态为 "),v("code",[_._v("SYN-SENT")]),_._v(" ，第三次握手后客户端和服务端的状态都为 "),v("code",[_._v("ESTABLISHED")]),_._v("。此时连接建立完成。")])]),_._v(" "),v("p",[_._v("从上面的过程可以发现"),v("strong",[_._v("第三次握手是可以携带数据的，前两次握手是不可以携带数据的")]),_._v("，这也是面试常问的题。")]),_._v(" "),v("h3",{attrs:{id:"_5-2-两次握手可以吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-两次握手可以吗"}},[_._v("#")]),_._v(" 5.2 两次握手可以吗")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("三次握手才可以阻止重复历史连接的初始化（主要原因）")]),_._v(" "),v("ul",[v("li",[_._v("比如客户端A发出连接请求，可能因为网络阻塞原因，A没有收到确认报文，于是A再重传一次连接请求。")]),_._v(" "),v("li",[_._v("连接成功，等待数据传输完毕后，就释放了连接。")]),_._v(" "),v("li",[_._v("然后A发出的第一个连接请求等到连接释放以后的某个时间才到达服务端B，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段。")]),_._v(" "),v("li",[_._v("如果不采用三次握手，只要B发出确认，就建立新的连接了，此时A不会响应B的确认且不发送数据，则B一直等待A发送数据，浪费资源。")])])]),_._v(" "),v("li",[v("p",[_._v("同步双方初始序列号")]),_._v(" "),v("p",[_._v("TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：")]),_._v(" "),v("ul",[v("li",[_._v("接收方可以去除重复的数据；")]),_._v(" "),v("li",[_._v("接收方可以根据数据包的序列号按序接收；")]),_._v(" "),v("li",[_._v("可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）")]),_._v(" "),v("li",[_._v("可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 "),v("code",[_._v("SYN")]),_._v(" 报文的时候，需要服务端回一个 "),v("code",[_._v("ACK")]),_._v(" 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，"),v("strong",[_._v("这样一来一回，才能确保双方的初始序列号能被可靠的同步。")])])])]),_._v(" "),v("li",[v("p",[_._v("避免资源浪费")]),_._v(" "),v("ul",[v("li",[_._v("如果客户端的 "),v("code",[_._v("SYN")]),_._v(" 阻塞了，重复发送多次 "),v("code",[_._v("SYN")]),_._v(" 报文，那么服务器在收到请求后就会"),v("strong",[_._v("建立多个冗余的无效链接，造成不必要的资源浪费。")])])])])]),_._v(" "),v("h3",{attrs:{id:"_5-3-三次握手异常情况分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-三次握手异常情况分析"}},[_._v("#")]),_._v(" 5.3 三次握手异常情况分析")]),_._v(" "),v("h4",{attrs:{id:"_1-客户端第一个「syn」包丢了。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-客户端第一个「syn」包丢了。"}},[_._v("#")]),_._v(" 1. 客户端第一个「SYN」包丢了。")]),_._v(" "),v("p",[_._v("如果客户端第一个「SYN」包丢了，也就是服务端根本就不知道客户端曾经发过包，那么处理流程主要在客户端。")]),_._v(" "),v("p",[_._v("而在 TCP 协议中，某端的一组「请求-应答」中，在一定时间范围内，只要没有收到应答的「ACK」包，无论是请求包对方没有收到，还是对方的应答包自己没有收到，均认为是丢包了，都会触发超时重传机制。")]),_._v(" "),v("p",[_._v("所以此时会进入重传「SYN」包。根据《TCP/IP详解卷Ⅰ：协议》中的描述，此时会尝试三次，间隔时间分别是 5.8s、24s、48s，三次时间大约是 76s 左右，而大多数伯克利系统将建立一个新连接的最长时间，限制为 75s。")]),_._v(" "),v("p",[_._v("也就是说三次握手第一个「SYN」包丢了，会重传，总的尝试时间是 75s。")]),_._v(" "),v("p",[_._v("参考：《TCP/IP 卷1 18|TCP连接的建立与终止》")]),_._v(" "),v("h4",{attrs:{id:"_2-服务端收到「syn」并回复的「syn-ack」包丢了。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-服务端收到「syn」并回复的「syn-ack」包丢了。"}},[_._v("#")]),_._v(" 2. 服务端收到「SYN」并回复的「SYN,ACK」包丢了。")]),_._v(" "),v("p",[_._v("此时服务端已经收到了数据包并回复，如果这个回复的「SYN,ACK」包丢了，站在客户端的角度，会认为是最开始的那个「SYN」丢了，那么就继续重传，就是我们前面说的「错误 1」 的流程。")]),_._v(" "),v("p",[_._v("而对服务端而言，如果发送的「SYN,ACK」包丢了，在超时时间内没有收到客户端发来的「ACK」包，也会触发重传，此时服务端处于 SYN_RCVD 状态，会依次等待 3s、6s、12s 后，重新发送「SYN,ACK」包。")]),_._v(" "),v("p",[_._v("而这个「SYN,ACK」包的重传次数，不同的操作系统下有不同的配置，例如在 Linux 下可以通过 tcp_synack_retries 进行配置，默认值为 5。如果这个重试次数内，仍未收到「ACK」应答包，那么服务端会自动关闭这个连接。")]),_._v(" "),v("p",[_._v("同时由于客户端在没有收到「SYN,ACK」时，也会进行重传，当客户端重传的「SYN」被收到后，服务端会立即重新发送「SYN,ACK」包。")]),_._v(" "),v("h4",{attrs:{id:"_3-客户端最后一次回复「syn-ack」的「ack」包丢了。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-客户端最后一次回复「syn-ack」的「ack」包丢了。"}},[_._v("#")]),_._v(" 3. 客户端最后一次回复「SYN,ACK」的「ACK」包丢了。")]),_._v(" "),v("p",[_._v("如果最后一个「ACK」包丢了，服务端因为收不到「ACK」会走重传机制，而客户端此时进入 ESTABLISHED 状态。")]),_._v(" "),v("p",[_._v("多数情况下，客户端进入 ESTABLISHED 状态后，则认为连接已建立，会立即发送数据。但是服务端因为没有收到最后一个「ACK」包，依然处于 SYN-RCVD 状态。")]),_._v(" "),v("p",[_._v("那么这里的关键，就在于服务端在处于 SYN-RCVD 状态下，收到客户端的数据包后如何处理？")]),_._v(" "),v("p",[_._v("这也是比较有争议的地方，有些资料里会写到当服务端处于 SYN-RCVD 状态下，收到客户端的数据包后，会直接回复 RTS 包响应，表示服务端错误，并进入 CLOSE 状态。")]),_._v(" "),v("p",[_._v("但是这样的设定有些过于严格，试想一下，服务端还在通过三次握手阶段确定对方是否真实存在，此时对方的数据已经发来了，那肯定是存在的。")]),_._v(" "),v("p",[_._v("所以当服务端处于 SYN-RCVD 状态下时，接收到客户端真实发送来的数据包时，会认为连接已建立，并进入 ESTABLISHED 状态。")]),_._v(" "),v("p",[_._v("实践出真知，具体测试流程可以参考这篇文章：《TCP三次握手的第三个ack丢了会怎样》")]),_._v(" "),v("p",[_._v("那么实际情况，为什么会这样呢？")]),_._v(" "),v("p",[_._v("当客户端在 ESTABLISHED 状态下，开始发送数据包时，会携带上一个「ACK」的确认序号，所以哪怕客户端响应的「ACK」包丢了，服务端在收到这个数据包时，能够通过包内 ACK 的确认序号，正常进入 ESTABLISHED 状态。")]),_._v(" "),v("p",[_._v("参考：《What if a TCP handshake segment is lost?》")]),_._v(" "),v("h4",{attrs:{id:"_4-客户端故意不发最后一次「syn」包。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-客户端故意不发最后一次「syn」包。"}},[_._v("#")]),_._v(" 4. 客户端故意不发最后一次「SYN」包。")]),_._v(" "),v("p",[_._v("前面一直在说正常的异常逻辑，双方都还算友善，按规矩做事，出现异常主要也是因为网络等客观问题，接下来说一个恶意的情况。")]),_._v(" "),v("p",[_._v("如果客户端是恶意的，在发送「SYN」包后，并收到「SYN,ACK」后就不回复了，那么服务端此时处于一种半连接的状态，虽然服务端会通过 tcp_synack_retries 配置重试的次数，不会无限等待下去，但是这也是有一个时间周期的。")]),_._v(" "),v("p",[_._v("如果短时间内存在大量的这种恶意连接，对服务端来说压力就会很大，这就是所谓的 SYN FLOOD 攻击。")]),_._v(" "),v("h3",{attrs:{id:"_5-4-四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-四次挥手"}},[_._v("#")]),_._v(" 5.4 四次挥手")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202205021539908.png",alt:"image-20220502153923839"}})]),_._v(" "),v("ol",[v("li",[_._v("A的应用进程先向其TCP发出连接释放报文段（ "),v("code",[_._v("FIN=1，seq=u")]),_._v(" ），并停止再发送数据，主动关闭 TCP连接，进入 "),v("code",[_._v("FIN-WAIT-1")]),_._v("（终止等待1）状态，等待B的确认。")]),_._v(" "),v("li",[_._v("B收到连接释放报文段后即发出确认报文段（ "),v("code",[_._v("ACK=1，ack=u+1，seq=v")]),_._v(" ），B进入 "),v("code",[_._v("CLOSE-WAIT")]),_._v("（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。")]),_._v(" "),v("li",[_._v("A收到B的确认后，进入 "),v("code",[_._v("FIN-WAIT-2")]),_._v("（终止等待2）状态，等待B发出的连接释放报文段。")]),_._v(" "),v("li",[_._v("B发送完数据，就会发出连接释放报文段（ "),v("code",[_._v("FIN=1，ACK=1，seq=w，ack=u+1")]),_._v("），B进入 "),v("code",[_._v("LAST-ACK")]),_._v("（最后确认）状态，等待A的确认。")]),_._v(" "),v("li",[_._v("A收到B的连接释放报文段后，对此发出确认报文段（"),v("code",[_._v("ACK=1，seq=u+1，ack=w+1")]),_._v("），A进入 "),v("code",[_._v("TIME-WAIT")]),_._v("（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间 2MSL （最大报文段生存时间）后，A才进入 "),v("code",[_._v("CLOSED")]),_._v("状态。B收到A发出的确认报文段后关闭连接，若没收到A发出 的确认报文段，B就会重传连接释放报文段。")])]),_._v(" "),v("h3",{attrs:{id:"_5-5-第四次挥手为什么要等待2msl"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-第四次挥手为什么要等待2msl"}},[_._v("#")]),_._v(" 5.5 第四次挥手为什么要等待2MSL")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("保证A发送的最后一个ACK报文段能够到达B")]),_._v("。这个 "),v("code",[_._v("ACK")]),_._v("报文段有可能丢失，B收不到这个确认报文，就会超时重传连接释放报文段，然后A可以在"),v("code",[_._v("2MSL")]),_._v(" 时间内收到这个重传的连接释放报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到 "),v("code",[_._v("CLOSED")]),_._v("状态，若A在"),v("code",[_._v("TIME-WAIT")]),_._v("状 态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的连接释放报文段，所以不会再发送一次确认报文段，B就无法正常进入到"),v("code",[_._v("CLOSED")]),_._v("状态")]),_._v(" "),v("li",[v("strong",[_._v("防止已失效的连接请求报文段出现在本连接中")]),_._v("。A在发送完最后一个 "),v("code",[_._v("ACK")]),_._v("报文段后，再经过2MSL， 就可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。")])]),_._v(" "),v("h3",{attrs:{id:"_5-6-四次挥手异常情况分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-6-四次挥手异常情况分析"}},[_._v("#")]),_._v(" 5.6 四次挥手异常情况分析")]),_._v(" "),v("h4",{attrs:{id:"_1-断开连接的-fin-包丢了。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-断开连接的-fin-包丢了。"}},[_._v("#")]),_._v(" 1. 断开连接的 FIN 包丢了。")]),_._v(" "),v("p",[_._v("我们前面一直强调过，如果一个包发出去，在一定时间内，只要没有收到对端的「ACK」回复，均认为这个包丢了，会触发超时重传机制。而不会关心到底是自己发的包丢了，还是对方的「ACK」丢了。")]),_._v(" "),v("p",[_._v("所以在这里，如果客户端率先发的「FIN」包丢了，或者没有收到对端的「ACK」回复，则会触发超时重传，直到触发重传的次数，直接关闭连接。")]),_._v(" "),v("p",[_._v("对于服务端而言，如果客户端发来的「FIN」没有收到，就没有任何感知。会在一段时间后，也关闭连接。")]),_._v(" "),v("h4",{attrs:{id:"_2-服务端第一次回复的-ack-丢了。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-服务端第一次回复的-ack-丢了。"}},[_._v("#")]),_._v(" 2. 服务端第一次回复的 ACK 丢了。")]),_._v(" "),v("p",[_._v("此时因为客户端没有收到「ACK」应答，会尝试重传之前的「FIN」请求，服务端收到后，又会立即再重传「ACK」。")]),_._v(" "),v("p",[_._v("而此时服务端已经进入 CLOSED-WAIT 状态，开始做断开连接前的准备工作。当准备好之后，会回复「FIN,ACK」，注意这个消息是携带了之前「ACK」的响应序号的。")]),_._v(" "),v("p",[_._v("只要这个消息没丢，客户端可以凭借「FIN,ACK」包中的响应序号，直接从 FIN-WAIT-1 状态，进入 TIME-WAIT 状态，开始长达 2MSL 的等待。")]),_._v(" "),v("h4",{attrs:{id:"_3-服务端发送的-fin-ack-丢了。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-服务端发送的-fin-ack-丢了。"}},[_._v("#")]),_._v(" 3. 服务端发送的 FIN,ACK 丢了。")]),_._v(" "),v("p",[_._v("服务端在超时后会重传，此时客户端有两种情况，要么处于 FIN-WAIT-2 状态（之前的 ACK 也丢了），会一直等待；要么处于 TIME-WAIT 状态，会等待 2MSL 时间。")]),_._v(" "),v("p",[_._v("也就是说，在一小段时间内客户端还在，客户端在收到服务端发来的「FIN,ACK」包后，也会回复一个「ACK」应答，并做好自己的状态切换。")]),_._v(" "),v("h4",{attrs:{id:"_4-客户端最后回复的-ack-丢了。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-客户端最后回复的-ack-丢了。"}},[_._v("#")]),_._v(" 4. 客户端最后回复的 ACK 丢了。")]),_._v(" "),v("p",[_._v("客户端在回复「ACK」后，会进入 TIME-WAIT 状态，开始长达 2MSL 的等待，服务端因为没有收到「ACK」的回复，会重试一段时间，直到服务端重试超时后主动断开。")]),_._v(" "),v("p",[_._v("或者等待新的客户端接入后，收到服务端重试的「FIN」消息后，回复「RST」消息，在收到「RST」消息后，复位服务端的状态。")]),_._v(" "),v("h4",{attrs:{id:"_5-客户端收到-ack-后，服务端跑路了。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-客户端收到-ack-后，服务端跑路了。"}},[_._v("#")]),_._v(" 5. 客户端收到 ACK 后，服务端跑路了。")]),_._v(" "),v("p",[_._v("客户端在收到「ACK」后，进入了 FIN-WAIT-2 状态，等待服务端发来的「FIN」包，而如果服务端跑路了，这个包永远都等不到。")]),_._v(" "),v("p",[_._v("在 TCP 协议中，是没有对这个状态的处理机制的。但是协议不管，系统来凑，操作系统会接管这个状态，例如在 Linux 下，就可以通过 tcp_fin_timeout 参数，来对这个状态设定一个超时时间。")]),_._v(" "),v("p",[_._v("需要注意的是，当超过 tcp_fin_timeout 的限制后，状态并不是切换到 TIME_WAIT，而是直接进入 CLOSED 状态。")]),_._v(" "),v("p",[_._v("参考：《关于FIN_WAIT2》")]),_._v(" "),v("h4",{attrs:{id:"_6-客户端收到-ack-后，客户端自己跑路了。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-客户端收到-ack-后，客户端自己跑路了。"}},[_._v("#")]),_._v(" 6. 客户端收到 ACK 后，客户端自己跑路了。")]),_._v(" "),v("p",[_._v("客户端收到「ACK」后直接跑路，服务端后续在发送的「FIN,ACK」就没有接收端，也就不会得到回复，会不断的走 TCP 的超时重试的机制，此时服务端处于 LAST-ACK 状态。")]),_._v(" "),v("p",[_._v("那就要分 2 种情况分析：")]),_._v(" "),v("p",[_._v("在超过一定时间后，服务端主动断开。")]),_._v(" "),v("p",[_._v("收到「RST」后，主动断开连接。")]),_._v(" "),v("p",[_._v("「RST」消息是一种重置消息，表示当前错误了，应该回到初始的状态。如果客户端跑路后有新的客户端接入，会在此发送「SYN」以期望建立连接，此时这个「SYN」将被忽略，并直接回复「FIN,ACK」消息，新客户端在收到「FIN」消息后是不会认的，并且会回复一个「RST」消息。")]),_._v(" "),v("p",[_._v("参考：《Coping with the TCP TIME-WAIT state on busy Linux servers》")]),_._v(" "),v("h3",{attrs:{id:"_5-7-为什么tcp连接的时候是3次，关闭的时候却是4次？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-7-为什么tcp连接的时候是3次，关闭的时候却是4次？"}},[_._v("#")]),_._v(" 5.7 为什么TCP连接的时候是3次，关闭的时候却是4次？")]),_._v(" "),v("p",[_._v("因为需要确保通信双方都能通知对方释放连接，假设客服端发送完数据向服务端发送释放连接请求，当客服端并不知道，服务端是否已经发送完数据，所以此次断开的是客服端到服务端的单向连接，服务端 返回给客户端确认报文后，服务端还能继续单向给客户端发送数据。当服务端发送完数据后还需要向客 户端发送释放连接请求，客户端返回确认报文，TCP连接彻底关闭。所以断开TCP连接需要客户端和服务 端分别通知对方并分别收到确认报文，一共需要四次。")]),_._v(" "),v("h3",{attrs:{id:"_5-8-tcp通信过程中异常情况整理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-8-tcp通信过程中异常情况整理"}},[_._v("#")]),_._v(" 5.8 TCP通信过程中异常情况整理")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("服务器主机崩溃\n客户端在给服务器发送数据时，由于收不到服务器端回传的ACK确认报文，正常情况下，客户端TCP均会进行超时重传，一般为重传12次大约9分钟后才放弃重传，并关闭客户端TCP链接。")])]),_._v(" "),v("li",[v("p",[_._v("服务器主机崩溃后重启\n如果服务器主机在崩溃重启的这段时间里，客户端没有向服务器发送数据，即客户端没有因重传次数超过限制关闭TCP链接。则在服务器重启后，当客户端再向服务器发送TCP报文时，由于服务器中的TCP链接已经关闭，会直接向客户端回复RST报文，客户端在接收RST报文后关闭自己的TCP链接。")])]),_._v(" "),v("li",[v("p",[_._v("服务器主机断网或者中间路由器出现故障\n与情况1类似，客户端会进行超时重传，直到重传次数超过后放弃重传，并关闭客户端TCP链接。(因为TCP中会忽略目的主机不可达和目的网络不可达的ICMP报文，并进行重传，直到重传总时间超过限制)")])]),_._v(" "),v("li",[v("p",[_._v("服务器主机断网或者中间路由器出现故障后又恢复\n如果在服务器主机断网或者中间路由器出现故障这段时间内，客户端和服务器之间没有进行相互通信，即双方均没有察觉对方目的不可达，则在恢复网络链接后两端的TCP链接均有效，能够正常继续进行通信。")])])]),_._v(" "),v("p",[_._v("如果在服务器主机断网或者中间路由器出现故障这段时间内，客户端因向服务器发送数据超时，并重传总时间超过限制关闭TCP链接。则再网络恢复后，服务器再向客户端发送TCP报文时，客户端也会直接恢复RST报文，服务器再收到RST报文后关闭自己的TCP链接。")]),_._v(" "),v("ol",{attrs:{start:"5"}},[v("li",[v("p",[_._v("服务器关机或服务器进程被终止\n正常情况下服务器主机被关机时，操作系统都会事先通知所有仍在运行的进程，并先将所有进程终止后，再继续关闭电脑。而所有的进程在被终止时，Unix操作系统内核都会事先去关闭所有已经打开的TCP链接，即向客户端发生FIN标志报文，进行四次握手关闭连接。\n            因此，对于这种情况，客户端是能够察觉到并正常关闭TCP链接。")])]),_._v(" "),v("li",[v("p",[_._v("服务器的端口被关闭\n如果在通信过程中，服务器的监听端口被管理员或系统禁掉，则当客户端再向服务器发送TCP报文时，服务器在收到该报文后，由于发送该目的端口没有处于监听状态，则会直接向客户端发送RST报文，客户端在收到RST报文后会直接关闭自己TCP链接。")])]),_._v(" "),v("li",[v("p",[_._v("TCP的保活机制\nTCP中的保活机制是一个可选项，并不是必须的。\n            主要用在服务器端，用于检测已建立TCP链接的客户端的状态，防止因客户端崩溃或者客户端网络不可达，而服务器端一直保持该TCP链接，占用服务器端的大量资源(因为Linux系统中可以创建的总TCP链接数是有限制的)。\n            保活机制原理：设置TCP保活机制的保活时间keepIdle，即在TCP链接超过该时间没有任何数据交互时，发送保活探测报文；设置保活探测报文的发送时间间隔keepInterval；设置保活探测报文的总发送次数keepCount。如果在keepCount次的保活探测报文均没有收到客户端的回应，则服务器端即关闭与客户端的TCP链接。\n            保活探测报文：\n            TCP保活探测报文的内容为，将之前已发送数据的最大序列号序列的减1，并设置数据大小为1个字节，数据内容为“0”，然后发送到客户端")])])]),_._v(" "),v("h3",{attrs:{id:"_5-9-如果已经建立了连接，但是客户端出现故障了怎么办？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-9-如果已经建立了连接，但是客户端出现故障了怎么办？"}},[_._v("#")]),_._v(" 5.9 如果已经建立了连接，但是客户端出现故障了怎么办？")]),_._v(" "),v("p",[_._v("或者说，如果三次握手阶段、四次挥手阶段的包丢失了怎么办？如“服务端重发 FIN丢失”的问题。")]),_._v(" "),v("p",[_._v("简而言之，通过"),v("strong",[_._v("定时器 + 超时重试机制")]),_._v("，尝试获取确认，直到最后会自动断开连接。")]),_._v(" "),v("p",[_._v("具体而言，TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 分钟发送一个探测报文段，若一连发送 10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。")]),_._v(" "),v("h3",{attrs:{id:"_5-10-time-wait-状态过多会产生什么后果？怎样处理？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-10-time-wait-状态过多会产生什么后果？怎样处理？"}},[_._v("#")]),_._v(" 5.10 TIME-WAIT 状态过多会产生什么后果？怎样处理？")]),_._v(" "),v("p",[_._v("从服务器来讲，短时间内关闭了大量的Client连接，就会造成服务器上出现大量的TIME_WAIT连接，严重消耗着服务器的资源，此时部分客户端就会显示连接不上。")]),_._v(" "),v("p",[_._v("从客户端来讲，客户端TIME_WAIT过多，就会导致端口资源被占用，因为端口就65536个，被占满就会导致无法创建新的连接。")]),_._v(" "),v("p",[v("strong",[_._v("解决办法：")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("服务器可以设置 SO_REUSEADDR 套接字选项来避免 TIME_WAIT状态，此套接字选项告诉内核，即使此端口正忙（处于\nTIME_WAIT状态），也请继续并重用它。")])]),_._v(" "),v("li",[v("p",[_._v("调整系统内核参数，修改/etc/sysctl.conf文件，即修改"),v("code",[_._v("net.ipv4.tcp_tw_reuse 和 tcp_timestamps")])]),_._v(" "),v("div",{staticClass:"language-bash extra-class"},[v("pre",{pre:!0,attrs:{class:"language-bash"}},[v("code",[_._v("net.ipv4.tcp_tw_reuse "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("1")]),_._v(" 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；\nnet.ipv4.tcp_tw_recycle "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("1")]),_._v(" 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。\n")])])])]),_._v(" "),v("li",[v("p",[_._v("强制关闭，发送 RST 包越过TIME_WAIT状态，直接进入CLOSED状态。")])])]),_._v(" "),v("h3",{attrs:{id:"_5-11-什么是-syn洪泛攻击？如何防范？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-11-什么是-syn洪泛攻击？如何防范？"}},[_._v("#")]),_._v(" 5.11 什么是 SYN洪泛攻击？如何防范？")]),_._v(" "),v("p",[_._v("SYN洪泛攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的半连接请求，耗费 CPU 和内存资源。")]),_._v(" "),v("p",[_._v("原理：")]),_._v(" "),v("ul",[v("li",[_._v("在三次握手过程中，服务器发送 "),v("code",[_._v("[SYN/ACK]")]),_._v(" 包（第二个包）之后、收到客户端的 "),v("code",[_._v("[ACK]")]),_._v(" 包（第三个包）之前的 TCP 连接称为半连接（half-open connect），此时服务器处于 "),v("code",[_._v("SYN_RECV")]),_._v("（等待客户端响应）状态。如果接收到客户端的 "),v("code",[_._v("[ACK]")]),_._v("，则 TCP 连接成功，如果未接受到，则会"),v("strong",[_._v("不断重发请求")]),_._v("直至成功。")]),_._v(" "),v("li",[_._v("SYN 攻击的攻击者在短时间内"),v("strong",[_._v("伪造大量不存在的 IP 地址")]),_._v("，向服务器不断地发送 "),v("code",[_._v("[SYN]")]),_._v(" 包，服务器回复 "),v("code",[_._v("[SYN/ACK]")]),_._v(" 包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时。")]),_._v(" "),v("li",[_._v("这些伪造的 "),v("code",[_._v("[SYN]")]),_._v(" 包将长时间占用未连接队列，影响了正常的 SYN，导致目标系统运行缓慢、网络堵塞甚至系统瘫痪。")])]),_._v(" "),v("p",[_._v("检测：当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。")]),_._v(" "),v("p",[_._v("防范：")]),_._v(" "),v("ul",[v("li",[_._v("通过防火墙、路由器等过滤网关防护。")]),_._v(" "),v("li",[_._v("通过加固 TCP/IP 协议栈防范，如增加最大半连接数，缩短超时时间。")]),_._v(" "),v("li",[_._v("SYN cookies技术。SYN Cookies 是对 TCP 服务器端的三次握手做一些修改，专门用来防范 SYN 洪泛攻击的一种手段。")])]),_._v(" "),v("h2",{attrs:{id:"_6-tcp-协议如何保证可靠传输"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-tcp-协议如何保证可靠传输"}},[_._v("#")]),_._v(" 6. TCP 协议如何保证可靠传输")]),_._v(" "),v("p",[_._v("主要有"),v("strong",[_._v("校验和")]),_._v("、"),v("strong",[_._v("序列号")]),_._v("、"),v("strong",[_._v("超时重传")]),_._v("、"),v("strong",[_._v("流量控制")]),_._v("及"),v("strong",[_._v("拥塞避免")]),_._v("等几种方法。")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("校验和")]),_._v("：在发送算和接收端分别计算数据的校验和，如果两者不一致，则说明数据在传输过程中出现了差错，TCP将丢弃和不确认此报文段。")]),_._v(" "),v("li",[v("strong",[_._v("序列号")]),_._v("：TCP会对每一个发送的字节进行编号，接收方接到数据后，会对发送方发送确认应答(ACK 报文)，并且这个ACK报文中带有相应的确认编号，告诉发送方，下一次发送的数据从编号多少开始 发。如果发送方发送相同的数据，接收端也可以通过序列号判断出，直接将数据丢弃。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202205021643773.png",alt:"image-20220502164333714"}})]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("超时重传")]),_._v("：在上面说了序列号的作用，但如果发送方在发送数据后一段时间内（可以设置重传计时 器规定这段时间）没有收到确认序号ACK，那么发送方就会重新发送数据。")]),_._v(" "),v("p",[_._v("这里发送方没有收到ACK可以分两种情况，如果是发送方发送的数据包丢失了，接收方收到发送方 重新发送的数据包后会马上给发送方发送ACK；如果是接收方之前接收到了发送方发送的数据包， 而返回给发送方的ACK丢失了，这种情况，发送方重传后，接收方会直接丢弃发送方冲重传的数据包，然后再次发送ACK响应报文")]),_._v(" "),v("p",[_._v("如果数据被重发之后还是没有收到接收方的确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长，直到最后关闭连接。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("流量控制")]),_._v("：如果发送端发送的数据太快，接收端来不及接收就会出现丢包问题。为了解决这个问题，TCP协议利用了滑动窗口进行了流量控制。在TCP首部有一个16位字段大小的窗口，窗口的大小就是"),v("strong",[_._v("接收端")]),_._v("接收数据缓冲区的剩余大小。接收端会在收到数据包后发送ACK报文时，将自己的窗 口大小填入ACK中，发送方会根据ACK报文中的窗口大小进而控制发送速度。如果窗口大小为零， 发送方会停止发送数据。")]),_._v(" "),v("p",[_._v("**滑动窗口：**在进行数据传输时，如果传输的数据比较大，就需要拆分为多个数据包进行发送。TCP 协议需要对数据进行确认后，才可以发送下一个数据包。这样一来，就会在等待确认应答包环节浪费时间。")]),_._v(" "),v("p",[_._v("为了避免这种情况，TCP引入了窗口概念。窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/NYfuxuyu/typora-pic/main/202205021702889.png",alt:""}})]),_._v(" "),v("p",[_._v("从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。")]),_._v(" "),v("p",[_._v("滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。")]),_._v(" "),v("p",[_._v("可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而"),v("strong",[_._v("滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值")]),_._v("。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("拥塞控制")]),_._v("：如果网络出现拥塞，则会产生丢包等问题，这时发送方会将丢失的数据包继续重传，网络拥塞会更加严重，所以在网络出现拥塞时应注意控制发送方的发送数据，降低整个网络的拥塞程度。拥塞控制主要有四部分组成：慢开始、拥塞避免、快重传、快恢复，如下图(图片来源于网络)。")])])]),_._v(" "),v("p",[_._v("这里的发送方会维护一个拥塞窗口的状态变量，它和流量控制的滑动窗口是不一样的，滑动窗口是 根据接收方数据缓冲区大小确定的，而拥塞窗口是根据网络的拥塞情况动态确定的，一般来说发送方真实的发送窗口为滑动窗口和拥塞窗口中的最小值。")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("慢开始")]),_._v("：为了避免一开始发送大量的数据而产生网络阻塞，会先初始化cwnd为1，当收到ACK 后到下一个传输轮次，cwnd为2，以此类推成指数形式增长。")]),_._v(" "),v("li",[v("strong",[_._v("拥塞避免")]),_._v("：因为cwnd的数量在慢开始是指数增长的，为了防止cwnd数量过大而导致网络阻 塞，会设置一个慢开始的门限值ssthresh，当cwnd>=ssthresh时，进入到拥塞避免阶段， cwnd每个传输轮次加1。但网络出现超时，会将门限值ssthresh变为出现超时cwnd数值的一 半，cwnd重新设置为1，如上图，在第12轮出现超时后，cwnd变为1，ssthresh变为12。")]),_._v(" "),v("li",[v("strong",[_._v("快重传")]),_._v("：在网络中如果出现超时或者阻塞，则按慢开始和拥塞避免算法进行调整。但如果只是 丢失某一个报文段，如下图(图片来源于网络)，则使用快重传算法。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202205021645954.png",alt:"image-20220502164555908"}})]),_._v(" "),v("p",[_._v("从上图可知，接收方正确地接收到M1和M2，而M3丢失，由于没有接收到M3，在接收方收到 M5、M6和M7时，并不会进行确认，也就是不会发送ACK。这时根据前面说的保证TCP可靠 性传输中的序列号的作用，接收方这时不会接收M5，M6，M7，接收方可以什么都不会，因 为发送方长时间未收到M3的确认报文，会对M3进行重传。除了这样，接收方也可以重复发送 M2的确认报文，这样发送端长时间未收到M3的确认报文也会继续发送M3报文。")]),_._v(" "),v("p",[v("strong",[_._v("但是根据快重传算法，要求在这种情况下，需要快速向发送端发送M2的确认报文，在发送方 收到三个M2的确认报文后，无需等待重传计时器所设置的时间，可直接进行M3的重传，这就是快重传")]),_._v("。")]),_._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[v("strong",[_._v("快恢复")]),_._v("：从上上图圈4可以看到，当发送收到三个重复的ACK，会进行快重传和快恢复。快恢复是指将ssthresh设置为发生快重传时的cwnd数量的一半，而cwnd不是设置为1而是设置为为门限值ssthresh，并开始拥塞避免阶段。")])]),_._v(" "),v("h2",{attrs:{id:"_7-http状态码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-http状态码"}},[_._v("#")]),_._v(" 7. HTTP状态码")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[_._v("状态码")]),_._v(" "),v("th",{staticStyle:{"text-align":"center"}},[_._v("类别")]),_._v(" "),v("th",{staticStyle:{"text-align":"center"}},[_._v("含义")])])]),_._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("1XX")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("Informational（信息性状态码）")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("接收的请求正在处理")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("2XX")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("Success（成功状态码）")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("请求正常处理完毕")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("3XX")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("Redirection（重定向状态码）")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("需要进行附加操作以完成请求")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("4XX")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("Client Error（客户端错误状态码）")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("服务器无法处理请求")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("5XX")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("Server Error（服务器错误状态码）")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("服务器处理请求出错")])])])]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("100 Continue")]),_._v("  ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("200 OK")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("204 No Content")]),_._v("  ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("206 Partial Content")]),_._v("  ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("301 Moved Permanently")]),_._v("  ：永久性重定向")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("302 Found")]),_._v("  ：临时性重定向")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("303 See Other")]),_._v("  ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。")])]),_._v(" "),v("li",[v("p",[_._v("注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("304 Not Modified")]),_._v("  ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("307 Temporary Redirect")]),_._v("  ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("400 Bad Request")]),_._v("  ：请求报文中存在语法错误。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("401 Unauthorized")]),_._v("  ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("403 Forbidden")]),_._v("  ：请求被拒绝。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("404 Not Found")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("500 Internal Server Error")]),_._v("  ：服务器正在执行请求时发生错误。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("503 Service Unavailable")]),_._v("  ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求")])])]),_._v(" "),v("h2",{attrs:{id:"_8-http-常用的请求方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-http-常用的请求方式"}},[_._v("#")]),_._v(" 8. HTTP 常用的请求方式")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[_._v("方法")]),_._v(" "),v("th",{staticStyle:{"text-align":"center"}},[_._v("作用")])])]),_._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("GET")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("获取资源")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("POST")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("传输实体主体")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("PUT")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("上传文件")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("DELETE")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("删除文件")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("HEAD")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("和GET方法类似，但只返回报文首部，不返回报文实体主体部分")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("PATCH")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("对资源进行部分修改")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("OPTIONS")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("查询指定的URL支持的方法")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("CONNECT")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("要求用隧道协议连接代理")])]),_._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[_._v("TRACE")]),_._v(" "),v("td",{staticStyle:{"text-align":"center"}},[_._v("服务器会将通信路径返回给客户端")])])])]),_._v(" "),v("p",[_._v("了方便记忆，可以将PUT、DELETE、POST、GET理解为客户端对服务端的增删改查。")]),_._v(" "),v("ul",[v("li",[_._v("PUT：上传文件，向服务器添加数据，可以看作增")]),_._v(" "),v("li",[_._v("DELETE：删除文件")]),_._v(" "),v("li",[_._v("POST：传输数据，向服务器提交数据，对服务器数据进行更新。")]),_._v(" "),v("li",[_._v("GET：获取资源，查询服务器资源")])]),_._v(" "),v("p",[v("strong",[_._v("GET请求和POST请求的区别")])]),_._v(" "),v("p",[v("strong",[_._v("使用上的区别")]),_._v("：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("GET使用URL或Cookie传参，而POST将数据放在BODY中，这个是因为HTTP协议用法的约定。")])]),_._v(" "),v("li",[v("p",[_._v("GET方式提交的数据有长度限制，则POST的数据则可以非常大”，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。")])]),_._v(" "),v("li",[v("p",[_._v("POST比GET安全，因为数据在地址栏上不可见”，这个说法没毛病，但依然不是GET和POST本身的区别。")])])]),_._v(" "),v("p",[v("strong",[_._v("本质区别")])]),_._v(" "),v("p",[_._v("GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。这个是它们本质区别。")]),_._v(" "),v("p",[_._v("幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。")]),_._v(" "),v("h2",{attrs:{id:"_9-http1-1特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-http1-1特性"}},[_._v("#")]),_._v(" 9. HTTP1.1特性")]),_._v(" "),v("p",[v("strong",[_._v("优点")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("简单")]),_._v("。HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式，易于理解，降低了学习和使用的门槛")]),_._v(" "),v("li",[_._v("**灵活易于扩展。**HTTP协议⾥的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。同时 HTTP 由于是⼯作在应⽤层（ OSI 第七层），则它下层可以随意变化。")]),_._v(" "),v("li",[v("strong",[_._v("应用广泛和跨平台")])])]),_._v(" "),v("p",[v("strong",[_._v("缺点")])]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("无状态")]),_._v("。无状态的好处是不会去记忆HTTP的状态，所以不需要额外的资源来记录状态信息，可以减轻服务器的压力，把更多的CPU和内存用来对外提供服务。坏处是完成相关的关联操作非常的麻烦，比如例如登录->添加购物⻋->下单->结算->⽀付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问⼀遍身份信息。")]),_._v(" "),v("p",[v("strong",[_._v("这时候就需要cookie和session")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("明文传输")]),_._v("。通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接⾁眼查")]),_._v(" "),v("p",[_._v("看，为我们调试⼯作带了极⼤的便利性，极不安全。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("不安全。")]),_._v("--\x3eHTTPS")]),_._v(" "),v("ul",[v("li",[_._v("通信使用明文，内容可能被窃听")]),_._v(" "),v("li",[_._v("不验证通信方的身份，因此有可能被伪装")]),_._v(" "),v("li",[_._v("无法验证报文的完整性，所以有可能被篡改")])])])]),_._v(" "),v("h2",{attrs:{id:"_10-http1-0和http1-1的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-http1-0和http1-1的区别"}},[_._v("#")]),_._v(" 10. HTTP1.0和HTTP1.1的区别")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("长连接")]),_._v("：HTTP 1.1支持长连接（Persistent Connection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启"),v("code",[_._v("Connection： keep-alive")]),_._v("，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。")]),_._v(" "),v("li",[v("strong",[_._v("缓存处理")]),_._v("：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略，可供选择的缓存头来控制缓存策略。")]),_._v(" "),v("li",[v("strong",[_._v("带宽优化及网络连接的使用")]),_._v("：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。")]),_._v(" "),v("li",[v("strong",[_._v("错误通知的管理")]),_._v("：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。")]),_._v(" "),v("li",[v("strong",[_._v("Host头处理")]),_._v("：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）")]),_._v(" "),v("li",[v("strong",[_._v("支持管道（pipeline）网络传输")]),_._v("，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。")])]),_._v(" "),v("p",[v("strong",[_._v("HTTP/1.1 还是有性能瓶颈")])]),_._v(" "),v("ul",[v("li",[_._v("请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 "),v("code",[_._v("Body")]),_._v(" 的部分；")]),_._v(" "),v("li",[_._v("发送冗长的首部。每次互相发送相同的首部造成的浪费较多；")]),_._v(" "),v("li",[_._v("服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是"),v("strong",[_._v("队头阻塞")]),_._v("；")]),_._v(" "),v("li",[_._v("没有请求"),v("strong",[_._v("优先级控制")]),_._v("；")]),_._v(" "),v("li",[_._v("请求只能从客户端开始，服务器只能"),v("strong",[_._v("被动")]),_._v("响应。")])]),_._v(" "),v("h2",{attrs:{id:"_11-http1-1和-http2-0的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-http1-1和-http2-0的区别"}},[_._v("#")]),_._v(" 11. HTTP1.1和 HTTP2.0的区别")]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("新的二进制格式")]),_._v("：HTTP1.1的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("多路复用")]),_._v("，即连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("头部压缩")]),_._v("，HTTP1.1的头部（header）带有大量信息，而且每次都要重复发送；HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("服务端推送")]),_._v("：服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。")])])]),_._v(" "),v("h2",{attrs:{id:"_12-http3与http2的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12-http3与http2的区别"}},[_._v("#")]),_._v(" 12. HTTP3与HTTP2的区别")]),_._v(" "),v("p",[_._v("HTTP/2 主要的问题在于，多个 HTTP 请求在复用⼀个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以⼀旦发生了丢包现象，就会触发 TCP 的重传机制，这样在⼀个 TCP 连接中的所有的 "),v("strong",[_._v("HTTP")]),_._v(" 请求都必须等待这个丢了的包被重传回来")]),_._v(" "),v("ul",[v("li",[_._v("HTTP/1.1 中的管道（ pipeline）传输中如果有⼀个请求阻塞了，那么队列后请求也统统被阻塞住了")]),_._v(" "),v("li",[_._v("HTTP/2 多个请求复⽤⼀个TCP连接，⼀旦发⽣丢包，就会阻塞住所有的 HTTP 请求。")])]),_._v(" "),v("p",[_._v("这些都是基于TCP传输层的问题，所以HTTP/3V把HTTP下层的TCP协议改成了UDP！")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202205021848915.png",alt:"image-20220502184830823"}})]),_._v(" "),v("p",[v("strong",[_._v("UDP的好处是不管顺序和丢包，所以不会出现HTTP/1.1的队头阻塞和HTTP/2的丢包和重传问题。")])]),_._v(" "),v("p",[v("strong",[_._v("⼤家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。")])]),_._v(" "),v("ul",[v("li",[_._v("QUIC 有自己的⼀套机制可以保证传输的可靠性的。当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到影响。")]),_._v(" "),v("li",[_._v("TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack 。")]),_._v(" "),v("li",[_._v("HTTPS 要建立⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS/1.3 的三次握⼿。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 "),v("strong",[_._v("3")]),_._v(" 次，减少了交互次数。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/NYfuxuyu/typora-pic/main/202205021848290.png",alt:"image-20220502184855188"}})]),_._v(" "),v("p",[_._v("所以， QUIC 是⼀个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复用的协议。")]),_._v(" "),v("h2",{attrs:{id:"_13-http和https的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-http和https的区别"}},[_._v("#")]),_._v(" 13. HTTP和HTTPS的区别")]),_._v(" "),v("ul",[v("li",[_._v("HTTP是超文本传输协议，信息是明文传输，HTTPS解决了HTTP不安全的缺陷，在TCP和HTTP之间加入了SSL安全协议")]),_._v(" "),v("li",[_._v("HTTP连接相对简单，而HTTPS在TCP三次握手之后还需要增加SSL握手的过程")]),_._v(" "),v("li",[_._v("HTTP端口号为80，HTTPS的端口号为443")])]),_._v(" "),v("p",[_._v("HTTPS在安全方面的做出的改进：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("窃听")]),_._v("：加密")]),_._v(" "),v("li",[v("strong",[_._v("篡改")]),_._v("：完整性")]),_._v(" "),v("li",[v("strong",[_._v("冒充")]),_._v("：认证，数字证书")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202205022034861.png",alt:"image-20211124144325088"}})]),_._v(" "),v("p",[v("strong",[_._v("机密性")])]),_._v(" "),v("p",[_._v("对称加密+非对称加密")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。")])]),_._v(" "),v("li",[v("p",[_._v("在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。")])])]),_._v(" "),v("p",[v("strong",[_._v("完整性")])]),_._v(" "),v("p",[_._v("摘要算法保证完整性")]),_._v(" "),v("p",[v("strong",[_._v("认证性")])]),_._v(" "),v("p",[_._v("数字证书")]),_._v(" "),v("p",[_._v("客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。这就存在些问题，如何保证公钥不被篡改和信任度？")]),_._v(" "),v("p",[_._v("所以这⾥就需要借助第三⽅权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。")]),_._v(" "),v("p",[v("strong",[_._v("RSA")]),_._v("基于大质数分解极其困难")]),_._v(" "),v("h2",{attrs:{id:"_14-ssl握手的过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-ssl握手的过程"}},[_._v("#")]),_._v(" 14. SSL握手的过程")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202205031330572.png",alt:"image-20220503133048483"}})]),_._v(" "),v("p",[_._v("SSL/TLS 协议建⽴的详细流程：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202205031336557.png",alt:""}})]),_._v(" "),v("ol",[v("li",[_._v("ClientHello")])]),_._v(" "),v("p",[_._v("⾸先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。")]),_._v(" "),v("p",[_._v("在这⼀步，客户端主要向服务器发送以下信息：")]),_._v(" "),v("p",[_._v("（1）客户端⽀持的 SSL/TLS 协议版本，如 TLS 1.2 版本。")]),_._v(" "),v("p",[_._v("（2）客户端⽣产的随机数（ Client Random ），后面用于产生「会话秘钥」。")]),_._v(" "),v("p",[_._v("（3）客户端支持的密码套件列表（密钥交换算法 **+**签名算法 "),v("strong",[_._v("+")]),_._v(" 对称加密算法 "),v("strong",[_._v("+")]),_._v(" 摘要算法），如 RSA 加密算法。")]),_._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[_._v("SeverHello")])]),_._v(" "),v("p",[_._v("服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello 。服务器回应的内容有如下内容：")]),_._v(" "),v("p",[_._v("（1）确认 SSL/ TLS 协议版本，如果浏览器不⽀持，则关闭加密通信。")]),_._v(" "),v("p",[_._v("（2）服务器产生的随机数（ Server Random ），后面用于产生「会话秘钥」。")]),_._v(" "),v("p",[_._v("（3）确认的密码套件列表，如 RSA 加密算法。")]),_._v(" "),v("p",[_._v("（4）服务器的数字证书。")]),_._v(" "),v("p",[_._v("​\t3.客户端回应")]),_._v(" "),v("p",[_._v("客户端收到服务器的回应之后，⾸先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。")]),_._v(" "),v("p",[_._v("如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：")]),_._v(" "),v("p",[_._v("（1）⼀个随机数（ pre-master key ）。该随机数会被服务器公钥加密。")]),_._v(" "),v("p",[_._v("（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。")]),_._v(" "),v("p",[_._v("（3）客户端握⼿结束通知，表示客户端的握⼿阶段已经结束。这⼀项同时把之前所有内容的发生的数据做个摘要，用来提供服务端校验。")]),_._v(" "),v("p",[_._v("上⾯第⼀项的随机数是整个握⼿阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的会话秘钥。")]),_._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[_._v("服务器的最后回应")])]),_._v(" "),v("p",[_._v("服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法，计算出本次通信的会话秘钥。然后，向客户端发出最后的信息：")]),_._v(" "),v("p",[_._v("（1）加密通信算法改变通知，表示随后的信息都将用会话秘钥加密通信。")]),_._v(" "),v("p",[_._v("（2）服务器握⼿结束通知，表示服务器的握⼿阶段已经结束。这⼀项同时把之前所有内容的发⽣的数据做个摘要，用来供客户端校验。")]),_._v(" "),v("p",[_._v("⾄此，整个 SSL/TLS 的握⼿阶段全部结束。接下来，客户端与服务器进⼊加密通信，就完全是使用普通的 HTTP协议，只不过用会话秘钥加密内容。")]),_._v(" "),v("h2",{attrs:{id:"_15-数字证书"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_15-数字证书"}},[_._v("#")]),_._v(" 15. 数字证书")]),_._v(" "),v("p",[_._v("数字证书和 CA 机构")]),_._v(" "),v("p",[_._v("⼀个数字证书通常包含了：")]),_._v(" "),v("ul",[v("li",[_._v("公钥")]),_._v(" "),v("li",[_._v("持有者信息")]),_._v(" "),v("li",[_._v("证书认证机构（CA）的信息")]),_._v(" "),v("li",[_._v("CA 对这份文件的数字签名及使⽤的算法；")]),_._v(" "),v("li",[_._v("证书有效")]),_._v(" "),v("li",[_._v("还有⼀些其他额外信息")])]),_._v(" "),v("p",[_._v("数字证书是用来认证公钥持有者的信息，以防止第三者的冒充。")]),_._v(" "),v("p",[_._v("为了让服务端的公钥能被大家信任，服务端的证书有CA签名，之所以要签名，是因为签名的作⽤可以避免中间⼈在获取证书时对证书内容的篡改。")]),_._v(" "),v("h3",{attrs:{id:"数字证书的签发和验证流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数字证书的签发和验证流程"}},[_._v("#")]),_._v(" "),v("strong",[_._v("数字证书的签发和验证流程")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202205031338664.png",alt:"image-20220503133836599"}})]),_._v(" "),v("p",[_._v("CA 签发证书的过程，如上图左边部分：")]),_._v(" "),v("ul",[v("li",[_._v("首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；")]),_._v(" "),v("li",[_._v("然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；")]),_._v(" "),v("li",[_._v("最后将 Certificate Signature 添加在文件证书上，形成数字证书；")])]),_._v(" "),v("p",[_._v("客户端校验服务端的数字证书的过程，如上图右边部分：")]),_._v(" "),v("ul",[v("li",[_._v("首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；")]),_._v(" "),v("li",[_._v("通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；")]),_._v(" "),v("li",[_._v("最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。")])]),_._v(" "),v("h3",{attrs:{id:"证书链"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#证书链"}},[_._v("#")]),_._v(" "),v("strong",[_._v("证书链")])]),_._v(" "),v("p",[_._v("但事实上，证书的验证过程中还存在⼀个证书信任链的问题，因为我们向 CA 申请的证书⼀般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/NYfuxuyu/typora-pic/main/202205031346209.png",alt:"img"}})]),_._v(" "),v("p",[_._v("对于这种三级层级关系的证书的验证过程如下：")]),_._v(" "),v("ul",[v("li",[_._v("客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。")]),_._v(" "),v("li",[_._v("请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。")]),_._v(" "),v("li",[_._v("“GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。")])]),_._v(" "),v("p",[_._v("在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。")]),_._v(" "),v("p",[_._v("总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。")]),_._v(" "),v("p",[_._v("这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/NYfuxuyu/typora-pic/main/202205031346611.png",alt:"img"}})]),_._v(" "),v("h2",{attrs:{id:"_16-post和get的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_16-post和get的区别"}},[_._v("#")]),_._v(" 16. POST和GET的区别")]),_._v(" "),v("ul",[v("li",[_._v("GET请求参数通过URL传递，POST的参数放在请求体中。")]),_._v(" "),v("li",[_._v("GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把请求头和 请求体一并发送出去；而对于POST，浏览器先发送请求头，服务器响应100 continue，浏览器再发送请求体。")]),_._v(" "),v("li",[_._v("GET请求会被浏览器主动缓存，而POST不会，除非手动设置。")]),_._v(" "),v("li",[_._v("GET请求只能进行url编码，而POST支持多种编码方式。")]),_._v(" "),v("li",[_._v("GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留")])]),_._v(" "),v("h2",{attrs:{id:"_17-dns解析的过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_17-dns解析的过程"}},[_._v("#")]),_._v(" 17. DNS解析的过程")]),_._v(" "),v("p",[_._v("DNS是集群式的工作方式还是单点式的，为什么？")]),_._v(" "),v("p",[_._v("答案是集群式的，很容易想到的一个方案就是只用一个DNS服务器，包含了所有域名和IP地址的映射。尽管这种设计方式看起来很简单，但是缺点显而易见，如果这个唯一的DNS服务器出了故障，那么就全完了，因特网就几乎崩了。为了避免这种情况出现，DNS系统采用的是分布式的层次数据数据库模式，还有缓存的机制也能解决这种问题。")]),_._v(" "),v("p",[v("strong",[_._v("DNS的工作流程")])]),_._v(" "),v("blockquote",[v("p",[_._v("主机向本地域名服务器的查询一般是采用递归查询，而本地域名服务器向根域名的查询一般是采用迭代查询")]),_._v(" "),v("p",[_._v("递归查询主机向本地域名发送查询请求报文，而本地域名服务器不知道该域名对应的IP地址时，本地域名会继续向根域名发送查询请求报文，不是通知主机自己向根域名发送查询请求报文。迭代查询是，本地域名服务器向根域名发出查询请求报文后，根域名不会继续向顶级域名服务器发送查询 请求报文，而是通知本地域名服务器向顶级域名发送查询请求报文。")])]),_._v(" "),v("ol",[v("li",[_._v("在浏览器中输入www.baidu.com域名，操作系统会先检查自己本地的hosts文件是否有这个域名的映射关系，如果有，就先调用这个IP地址映射，完成域名解析。")]),_._v(" "),v("li",[_._v("如果hosts文件中没有，则查询本地DNS解析器缓存，如果有，则完成地址解析。")]),_._v(" "),v("li",[_._v("如果本地DNS解析器缓存中没有，则去查找本地DNS服务器，如果查到，完成解析。")]),_._v(" "),v("li",[_._v("如果没有，则本地服务器会向根域名服务器发起查询请求。根域名服务器会告诉本地域名服务器去 查询哪个顶级域名服务器。")]),_._v(" "),v("li",[_._v("本地域名服务器向顶级域名服务器发起查询请求，顶级域名服务器会告诉本地域名服务器去查找哪个权限域名服务器")]),_._v(" "),v("li",[_._v("本地域名服务器向权限域名服务器发起查询请求，权限域名服务器告诉本地域名服务器www.baid u.com所对应的IP地址。")]),_._v(" "),v("li",[_._v("本地域名服务器告诉主机www.baidu.com所对应的IP地址。")])]),_._v(" "),v("h2",{attrs:{id:"_18-arp协议详解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_18-arp协议详解"}},[_._v("#")]),_._v(" 18. ARP协议详解")]),_._v(" "),v("p",[_._v("ARP协议属于网络层的协议，主要作用是实现从IP地址转换为MAC地址。在每个主机或者路由器中都建 有一个ARP缓存表，表中有IP地址及IP地址对应的MAC地址。先来看一下什么时IP地址和MAC地址。")]),_._v(" "),v("ul",[v("li",[_._v("IP地址：IP地址是指互联网协议地址，IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异")]),_._v(" "),v("li",[_._v("MAC地址：MAC地址又称物理地址，由网络设备制造商生产时写在硬件内部，不可更改，并且每个以太网设备的MAC地址都是唯一的")])]),_._v(" "),v("p",[_._v("数据在传输过程中，会先从高层传到底层，然后在通信链路上传输。从下图可以看到TCP报文在网络层 会被封装成IP数据报，在数据链路层被封装成MAC帧，然后在通信链路中传输。在网络层使用的是IP地址，在数据据链路层使用的是MAC地址。MAC帧在传送时的源地址和目的地址使用的都是MAC地址，在通信链路上的主机或路由器也都是根据MAC帧首部的MAC地址接收MAC帧。并且在数据链路层是看不到 IP地址的，只有当数据传到网络层时去掉MAC帧的首部和尾部时才能在IP数据报的首部中找到源IP地址和目的地址。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202205031532846.png",alt:"image-20220503153243782"}})]),_._v(" "),v("p",[_._v("网络层实现的是主机之间的通信，而链路层实现的是链路之间的通信，所以从下图可以看出，在数据传输过程中，IP数据报的源地址(IP1)和目的地址(IP2)是一直不变的，而MAC地址(硬件地址)却一直随着链路的改变而改变。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/NYfuxuyu/typora-pic/main/202205031533711.png",alt:"image-20220503153302655"}})]),_._v(" "),v("p",[_._v("ARP的工作流程(面试时问ARP协议主要说这个就可以了)：")]),_._v(" "),v("ol",[v("li",[_._v("在局域网内，主机A要向主机B发送IP数据报时，首先会在主机A的ARP缓存表中查找是否有IP地址及其对应的MAC地址，如果有，则将MAC地址写入到MAC帧的首部，并通过局域网将该MAC帧发 送到MAC地址所在的主机B。")]),_._v(" "),v("li",[_._v("如果主机A的ARP缓存表中没有主机B的IP地址及所对应的MAC地址，主机A会在局域网内广播发送 一个ARP请求分组。局域网内的所有主机都会收到这个ARP请求分组。")]),_._v(" "),v("li",[_._v("主机B在看到主机A发送的ARP请求分组中有自己的IP地址，会像主机A以单播的方式发送一个带有自己MAC地址的响应分组。")]),_._v(" "),v("li",[_._v("主机A收到主机B的ARP响应分组后，会在ARP缓存表中写入主机B的IP地址及其IP地址对应的MAC地址")]),_._v(" "),v("li",[_._v("如果主机A和主机B不在同一个局域网内，即使知道主机B的MAC地址也是不能直接通信的，必须通过路由器转发到主机B的局域网才可以通过主机B的MAC地址找到主机B。并且主机A和主机B已经 可以通信的情况下，主机A的ARP缓存表中寸的并不是主机B的IP地址及主机B的MAC地址，而是主机B的IP地址及该通信链路上的下一跳路由器的MAC地址。这就是上图中的源IP地址和目的IP地址一直不变，而MAC地址却随着链路的不同而改变。")]),_._v(" "),v("li",[_._v("如果主机A和主机B不在同一个局域网，参考上图中的主机H1和主机H2，这时主机H1需要先广播找到路由器R1的MAC地址，再由R1广播找到路由器R2的MAC地址，最后R2广播找到主机H2的MAC 地址，建立起通信链路。")])]),_._v(" "),v("h2",{attrs:{id:"_19-session、cookie和token的主要区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_19-session、cookie和token的主要区别"}},[_._v("#")]),_._v(" 19. Session、Cookie和Token的主要区别")]),_._v(" "),v("p",[_._v("HTTP协议是无状态的，即服务器无法判断用户身份。Session和Cookie可以用来进行身份辨认。")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("Cookie")]),_._v(" "),v("p",[_._v("Cookie是保存在客户端一个小数据块，其中包含了用户信息。当客户端向服务端发起请求，服务端会像客户端浏览器发送一个Cookie，客户端会把Cookie存起来，当下次客户端再次请求服务端 时，会携带上这个Cookie，服务端会通过这个Cookie来确定身份。")]),_._v(" "),v("p",[v("strong",[_._v("Cookie 主要用于以下三个方面：")])]),_._v(" "),v("ul",[v("li",[_._v("会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）")]),_._v(" "),v("li",[_._v("个性化设置（如用户自定义设置、主题等）")]),_._v(" "),v("li",[_._v("浏览器行为跟踪（如跟踪分析用户行为等）")])])]),_._v(" "),v("li",[v("p",[_._v("Session")]),_._v(" "),v("p",[_._v("Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。")]),_._v(" "),v("p",[_._v("Session是通过Cookie实现的，和Cookie不同的是，Session是存在服务端的。当客户端浏览器第 一次访问服务器时，服务器会为浏览器创建一个sessionid，将sessionid放到Cookie中，存在客户端浏览器。比如浏览器访问的是购物网站，将一本《图解HTTP》放到了购物车，当浏览器再次访问服务器时，服务器会取出Cookie中的sessionid，并根据sessionid获取会话中的存储的信息，确认浏览器的身份是上次将《图解HTTP》放入到购物车那个用户。")])]),_._v(" "),v("li",[v("p",[_._v("Token")]),_._v(" "),v("p",[_._v("客户端在浏览器第一次访问服务端时，服务端生成的一串字符串作为Token发给客户端浏览器，下次浏览器在访问服务端时携带token即可无需验证用户名和密码，省下来大量的资源开销。")]),_._v(" "),v("p",[v("a",{attrs:{href:"%5Bcookie%E3%80%81session%E4%B8%8Etoken%E7%9A%84%E7%9C%9F%E6%AD%A3%E5%8C%BA%E5%88%AB_%E4%B8%9C%E5%8C%97%E4%B8%80%E7%BB%9D%E3%80%81%E8%8B%B1%E4%BF%8A%E4%BE%A0%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2_token%E5%92%8Csession%E5%92%8Ccookie%E7%9A%84%E5%8C%BA%E5%88%AB%5D(https://blog.csdn.net/whl190412/article/details/90024671)"}},[_._v("cookie、session与token的真正区别")])])])]),_._v(" "),v("h3",{attrs:{id:"_19-1-cookie和session的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_19-1-cookie和session的区别"}},[_._v("#")]),_._v(" 19.1 Cookie和Session的区别")]),_._v(" "),v("ul",[v("li",[_._v("作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。")]),_._v(" "),v("li",[_._v("存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。")]),_._v(" "),v("li",[_._v("有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。")]),_._v(" "),v("li",[_._v("隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。")]),_._v(" "),v("li",[_._v("存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。")])]),_._v(" "),v("h3",{attrs:{id:"_19-2-cookie-和-session-是如何配合的呢？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_19-2-cookie-和-session-是如何配合的呢？"}},[_._v("#")]),_._v(" 19.2 Cookie 和 Session 是如何配合的呢？")]),_._v(" "),v("p",[_._v("用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。")]),_._v(" "),v("p",[_._v("当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。")]),_._v(" "),v("p",[_._v("根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。")]),_._v(" "),v("h3",{attrs:{id:"_19-3-如何考虑分布式-session-问题？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_19-3-如何考虑分布式-session-问题？"}},[_._v("#")]),_._v(" 19.3 如何考虑分布式 Session 问题？")]),_._v(" "),v("p",[_._v("在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。")]),_._v(" "),v("p",[_._v("分布式 Session 一般会有以下几种解决方案：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("客户端存储")]),_._v("：直接将信息存储在cookie中，cookie是存储在客户端上的一小段数据，客户端通过http协议和服务器进行cookie交互，通常用来存储一些不敏感信息")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("Nginx ip_hash 策略")]),_._v("：服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。")]),_._v(" "),v("li",[v("strong",[_._v("Session 复制")]),_._v("：任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。")]),_._v(" "),v("li",[v("strong",[_._v("共享 Session")]),_._v("：服务端无状态话，将用户的 Session 等信息使用缓存中间件（如Redis）来统一管理，保障分发到每一个服务器的响应结果都一致。")])]),_._v(" "),v("p",[_._v("建议采用共享 Session的方案。")]),_._v(" "),v("h3",{attrs:{id:"_19-4-如果客户端禁止-cookie-能实现-session-还能用吗？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_19-4-如果客户端禁止-cookie-能实现-session-还能用吗？"}},[_._v("#")]),_._v(" 19.4 "),v("strong",[_._v("如果客户端禁止 cookie 能实现 session 还能用吗？")])]),_._v(" "),v("p",[_._v("可以，Session的作用是在服务端来保持状态，通过sessionid来进行确认身份，但sessionid一般是通过 Cookie来进行传递的。如果Cooike被禁用了，可以通过在URL中传递sessionid")]),_._v(" "),v("h2",{attrs:{id:"_20-在浏览器中输⼊url地址到显示主页的过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_20-在浏览器中输⼊url地址到显示主页的过程"}},[_._v("#")]),_._v(" 20. 在浏览器中输⼊url地址到显示主页的过程")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202205031603502.png",alt:"img"}})]),_._v(" "),v("p",[_._v("上图有一个错误，请注意，是"),v("a",{attrs:{href:"https://so.csdn.net/so/search?q=OSPF&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[_._v("OSPF"),v("OutboundLink")],1),_._v("不是OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议,是由Internet工程任务组开发的路由选择协议")]),_._v(" "),v("p",[_._v("大致过程为：")]),_._v(" "),v("ul",[v("li",[_._v("DNS解析")]),_._v(" "),v("li",[_._v("TCP连接")]),_._v(" "),v("li",[_._v("发送HTTP请求")]),_._v(" "),v("li",[_._v("服务器处理请求并返回HTTP报文")]),_._v(" "),v("li",[_._v("浏览器解析渲染页面")])]),_._v(" "),v("h3",{attrs:{id:"dns解析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dns解析"}},[_._v("#")]),_._v(" DNS解析")]),_._v(" "),v("p",[_._v("DNS解析的过程就是寻找哪台机器上有你需要资源的过程。当你在浏览器中输入一个地址时，例如www.baidu.com，其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换。")]),_._v(" "),v("p",[v("strong",[_._v("首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。")])]),_._v(" "),v("h3",{attrs:{id:"tcp连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp连接"}},[_._v("#")]),_._v(" TCP连接")]),_._v(" "),v("p",[_._v("在TCP/IP协议中,TCP协议提供可靠的连接服务,采用三次握手建立一个连接")]),_._v(" "),v("h3",{attrs:{id:"发送http请求"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#发送http请求"}},[_._v("#")]),_._v(" 发送HTTP请求")]),_._v(" "),v("p",[_._v("发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。")]),_._v(" "),v("h3",{attrs:{id:"服务器处理请求并返回http报文"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务器处理请求并返回http报文"}},[_._v("#")]),_._v(" 服务器处理请求并返回HTTP报文")]),_._v(" "),v("p",[_._v("后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行")]),_._v(" "),v("h3",{attrs:{id:"浏览器解析渲染页面"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器解析渲染页面"}},[_._v("#")]),_._v(" 浏览器解析渲染页面")]),_._v(" "),v("h2",{attrs:{id:"_21-web安全"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_21-web安全"}},[_._v("#")]),_._v(" 21. web安全")]),_._v(" "),v("h3",{attrs:{id:"_21-1-什么是ddos攻击？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_21-1-什么是ddos攻击？"}},[_._v("#")]),_._v(" 21.1 什么是DDos攻击？")]),_._v(" "),v("p",[_._v("DDos全称Distributed Denial of Service，分布式拒绝服务攻击。最基本的DOS攻击过程如下：")]),_._v(" "),v("ol",[v("li",[_._v("客户端向服务端发送请求链接数据包。")]),_._v(" "),v("li",[_._v("服务端向客户端发送确认数据包。")]),_._v(" "),v("li",[_._v("客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认")])]),_._v(" "),v("p",[_._v("DDoS则是采用分布式的方法，通过在网络上占领多台“肉鸡”，用多台计算机发起攻击。")]),_._v(" "),v("p",[_._v("DOS攻击现在基本没啥作用了，因为服务器的性能都很好，而且是多台服务器共同作用，1V1的模式黑客无法占上风。对于DDOS攻击，预防方法有：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("减少SYN timeout时间")]),_._v("。在握手的第三步，服务器会等待30秒-120秒的时间，减少这个等待时间就能释放更多的资源。")]),_._v(" "),v("li",[v("strong",[_._v("限制同时打开的SYN半连接数目。")])])]),_._v(" "),v("h3",{attrs:{id:"_21-2-什么是xss攻击？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_21-2-什么是xss攻击？"}},[_._v("#")]),_._v(" 21.2 什么是XSS攻击？")]),_._v(" "),v("p",[_._v("SS也称 cross-site scripting，"),v("strong",[_._v("跨站脚本")]),_._v("。这种攻击是"),v("strong",[_._v("由于服务器将攻击者存储的数据原原本本地显示给其他用户所致的")]),_._v("。比如一个存在XSS漏洞的论坛，用户发帖时就可以引入"),v("strong",[_._v("带有＜script＞标签的代码")]),_._v("，导致恶意代码的执行。")]),_._v(" "),v("p",[_._v("预防措施有：")]),_._v(" "),v("ul",[v("li",[_._v("前端：过滤。")]),_._v(" "),v("li",[_._v("后端：转义，比如go自带的处理器就具有转义功能。")])]),_._v(" "),v("h3",{attrs:{id:"_21-3-sql注入是什么，如何避免sql注入？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_21-3-sql注入是什么，如何避免sql注入？"}},[_._v("#")]),_._v(" 21.3 SQL注入是什么，如何避免SQL注入？")]),_._v(" "),v("p",[_._v("SQL 注入就是在用户输入的字符串中加入 SQL 语句，如果在设计不良的程序中忽略了检查，那么这些注入进去的 SQL 语句就会被数据库服务器误认为是正常的 SQL 语句而运行，攻击者就可以执行计划外的命令或访问未被授权的数据。")]),_._v(" "),v("p",[v("strong",[_._v("SQL注入的原理主要有以下 4 点")])]),_._v(" "),v("ul",[v("li",[_._v("恶意拼接查询")]),_._v(" "),v("li",[_._v("利用注释执行非法命令")]),_._v(" "),v("li",[_._v("传入非法参数")]),_._v(" "),v("li",[_._v("添加额外条件")])]),_._v(" "),v("p",[v("strong",[_._v("避免SQL注入的一些方法")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("限制数据库权限，给用户提供仅仅能够满足其工作的最低权限。")]),_._v(" "),v("li",[_._v("对进入数据库的特殊字符（’”\\尖括号&*;等）转义处理。")]),_._v(" "),v("li",[_._v("提供参数化查询接口，不要直接使用原生SQL。")])])])}),[],!1,null,null,null);t.default=e.exports}}]);