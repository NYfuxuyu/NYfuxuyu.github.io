(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{490:function(t,a,s){"use strict";s.r(a);var n=s(4),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("blockquote",[s("p",[t._v("Java集合")])]),t._v(" "),s("h2",{attrs:{id:"常用的集合类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常用的集合类"}},[t._v("#")]),t._v(" 常用的集合类")]),t._v(" "),s("p",[t._v("Java集合类主要由两个根接口"),s("strong",[t._v("Collection")]),t._v("和"),s("strong",[t._v("Map")]),t._v("派生出来的，Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此Java集合大致也可分成List、Set、Queue、Map四种接口体系。")]),t._v(" "),s("p",[t._v("集合的框架图")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209131438743.png",alt:"image-20220418214233737"}})]),t._v(" "),s("p",[t._v("图中，List代表了有序可重复集合，可直接根据元素的索引来访问；Set代表无序不可重复集合，只能根据元素本身来访问；Queue是队列集合。")]),t._v(" "),s("p",[t._v("Map代表的是存储key-value对的集合，可根据元素的key来访问value。")]),t._v(" "),s("p",[t._v("上图中淡绿色背景覆盖的是集合体系中常用的实现类，分别是ArrayList、LinkedList、ArrayQueue、HashSet、TreeSet、HashMap、TreeMap等实现类。")]),t._v(" "),s("h2",{attrs:{id:"list，set，map三者的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#list，set，map三者的区别"}},[t._v("#")]),t._v(" List，Set，Map三者的区别")]),t._v(" "),s("ul",[s("li",[s("p",[s("code",[t._v("List")]),t._v("：有序集合（有序指存入的顺序和取出的顺序相同，不是按照元素的某些特性排序），可存储重复元素，可存储多个 null 。")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("Set")]),t._v(" ：无序集合（元素存入和取出顺序不一定相同），不可存储重复元素，只能存储一个 null 。")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("Map")]),t._v(" ：使用键值对的方式对元素进行存储， key是无序的，且是唯一的。 value 值不唯一。不同的key 值可以对应相同的 value 值。")])])]),t._v(" "),s("h2",{attrs:{id:"集合类的线程安全性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#集合类的线程安全性"}},[t._v("#")]),t._v(" 集合类的线程安全性")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("线程安全的：")]),t._v(" "),s("ul",[s("li",[t._v("Hashtable：比HashMap多了个线程安全。")]),t._v(" "),s("li",[t._v("ConcurrentHashMap:是一种高效但是线程安全的集合。")]),t._v(" "),s("li",[t._v("Vector：比Arraylist多了个同步化机制。")]),t._v(" "),s("li",[t._v("Stack：栈，也是线程安全的，继承于Vector。")]),t._v(" "),s("li",[t._v("enumeration ：枚举")])])]),t._v(" "),s("li",[s("p",[t._v("线性不安全的：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("HashMap")])]),t._v(" "),s("li",[s("p",[t._v("Arraylist")])]),t._v(" "),s("li",[s("p",[t._v("LinkedList")])]),t._v(" "),s("li",[s("p",[t._v("HashSet")])]),t._v(" "),s("li",[s("p",[t._v("TreeSet")])]),t._v(" "),s("li",[s("p",[t._v("TreeMap")])])])])]),t._v(" "),s("h2",{attrs:{id:"迭代器iterator是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#迭代器iterator是什么"}},[t._v("#")]),t._v(" 迭代器Iterator是什么")]),t._v(" "),s("p",[s("code",[t._v("Iterator")]),t._v("是 Java 迭代器最简单的实现，它不是一个集合，它是一种用于访问集合的方法， "),s("code",[t._v("Iterator")]),t._v("接口提供遍历任何 "),s("code",[t._v("Collection")]),t._v(" 的接口")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Collection")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("E")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Iterable")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("E")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Iterator")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("E")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("iterator")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("主要有三个方法："),s("code",[t._v("hasNext()")]),t._v("、"),s("code",[t._v("next()")]),t._v("和"),s("code",[t._v("remove()")]),t._v("。")]),t._v(" "),s("ul",[s("li",[t._v("遍历。使用Iterator，可以遍历所有集合，如Map，List，Set；但只能在向前方向上遍历集合中的元素。")])]),t._v(" "),s("p",[t._v("使用ListIterator，只能遍历List实现的对象，但可以向前和向后遍历集合中的元素。")]),t._v(" "),s("ul",[s("li",[t._v("添加元素。Iterator无法向集合中添加元素；而，ListIteror可以向集合添加元素。")]),t._v(" "),s("li",[t._v("修改元素。Iterator无法修改集合中的元素；而，ListIterator可以使用set()修改集合中的元素。")]),t._v(" "),s("li",[t._v("索引。Iterator无法获取集合中元素的索引；而，使用ListIterator，可以获取集合中元素的索引。")])]),t._v(" "),s("h2",{attrs:{id:"collection如何迭代"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#collection如何迭代"}},[t._v("#")]),t._v(" Collection如何迭代")]),t._v(" "),s("p",[t._v("Collection的迭代有很多种方式：")]),t._v(" "),s("p",[t._v("1、通过普通for循环迭代")]),t._v(" "),s("p",[t._v("2、通过增强for循环迭代")]),t._v(" "),s("p",[t._v("3、使用Iterator迭代")]),t._v(" "),s("p",[t._v("4、使用Stream迭代")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" list "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ImmutableList")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("of")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Hollis"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hollischuang"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 普通for循环遍历")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("size")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//增强for循环遍历")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" s "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Iterator遍历")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Iterator")]),t._v(" it "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("iterator")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("it"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hasNext")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("it"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Stream 遍历")]),t._v("\nlist"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("forEach")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nlist"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("stream")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("forEach")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h2",{attrs:{id:"java集合的快速失败机制-fail-fast和安全失败机fail-safe"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java集合的快速失败机制-fail-fast和安全失败机fail-safe"}},[t._v("#")]),t._v(" Java集合的快速失败机制 fail-fast和安全失败机fail-safe")]),t._v(" "),s("h3",{attrs:{id:"fail-fast-快速失败"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fail-fast-快速失败"}},[t._v("#")]),t._v(" fail-fast(快速失败)")]),t._v(" "),s("p",[t._v("Java的快速失败机制是Java集合框架中的一种错误检测机制，当多个线程同时对集合中的内容进行 修改时可能就会抛出"),s("code",[t._v("ConcurrentModificationException")]),t._v(" 异常。其实不仅仅是在多线程状态下， 在单线程中用增强 for 循环中一边遍历集合一边修改集合的元素也会抛出 "),s("code",[t._v("ConcurrentModificationException")]),t._v("异常。看下面代码")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" list "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("remove")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//运行时抛出ConcurrentModificationException异常")]),t._v("\n       "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("正确的做法是用迭代器的"),s("code",[t._v("remove()")]),t._v(" 方法，便可正常运行。")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" list "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Iterator")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" it "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("iterator")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("it"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hasNext")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            it"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("remove")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n       "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("造成这种情况的原因是什么？细心的同学可能已经发现两次调用的"),s("code",[t._v("remove()")]),t._v("方法不同，一个带参数据，一个不带参数，这个后面再说，经过查看 "),s("code",[t._v("ArrayList")]),t._v(" 源码，找到了抛出异常的代码")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("checkForComodification")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("modCount "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" expectedModCount"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ConcurrentModificationException")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("从上面代码中可以看到如果 "),s("code",[t._v("modCount")]),t._v(" 和 "),s("code",[t._v("expectedModCount")]),t._v("这两个变量不相等就会抛出 "),s("code",[t._v("ConcurrentModificationException")]),t._v("异常。那这两个变量又是什么呢？继续看源码")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("transient")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" modCount "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//在AbstractList中定义的变量")]),t._v("\n")])])]),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" expectedModCount "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" modCount"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//在ArrayList中的内部类Itr中定义的变量")]),t._v("\n")])])]),s("p",[t._v("从上面代码可以看到， "),s("code",[t._v("modCount")]),t._v(" 初始值为0，而 "),s("code",[t._v("expectedModCount")]),t._v("初始值等于 "),s("code",[t._v("modCount")]),t._v(" 。也 就是说在遍历的时候直接调用集合的 "),s("code",[t._v("remove()")]),t._v("方法会导致 "),s("code",[t._v("modCount")]),t._v("不等于 "),s("code",[t._v("expectedModCount")]),t._v("进而抛出 "),s("code",[t._v("ConcurrentModificationException")]),t._v("异常，而使用迭代器的"),s("code",[t._v("remove()")]),t._v("方法则不会出现 这种问题。那么只能在看看 "),s("code",[t._v("remove()")]),t._v("方法的源码找找原因了")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("E")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("remove")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("rangeCheck")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        modCount"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("E")]),t._v(" oldValue "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("elementData")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" numMoved "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" size "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" index "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("numMoved "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("arraycopy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("elementData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" index"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" elementData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                             numMoved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        elementData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// clear to let GC do its work")]),t._v("\n "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" oldValue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("从上面代码中可以看到只有 "),s("code",[t._v("modCount++")]),t._v(" 了，而 "),s("code",[t._v("expectedModCount")]),t._v("没有操作，当每一次迭代时， 迭代器会比较 "),s("code",[t._v("expectedModCount")]),t._v("和"),s("code",[t._v("modCount")]),t._v("的值是否相等，所以在调用 "),s("code",[t._v("remove()")]),t._v("方法后，"),s("code",[t._v("modCount")]),t._v("不等于 "),s("code",[t._v("expectedModCount")]),t._v("了，这时就了报 "),s("code",[t._v("ConcurrentModificationException")]),t._v(" 异常。但用迭代器中"),s("code",[t._v("remove()")]),t._v(" 的方法为什么不抛异常呢？原来迭代器调用的 "),s("code",[t._v("remove()")]),t._v(" 方法和上面 的 "),s("code",[t._v("remove()")]),t._v("方法不是同一个！迭代器调用的 "),s("code",[t._v("remove()")]),t._v("方法长这样：")]),t._v(" "),s("p",[t._v("上面介绍的只是单线程的情况，用迭代器调用"),s("code",[t._v("remove()")]),t._v("方法即可正常运行，但如果是多线程会怎么样呢？")]),t._v(" "),s("p",[t._v("答案是在多线程的情况下即使用了迭代器调用 "),s("code",[t._v("remove()")]),t._v(" 方法，还是会报 "),s("code",[t._v("ConcurrentModificationException")]),t._v(" 异常。这又是为什么呢？还是要从 "),s("code",[t._v("expectedModCount")]),t._v(" 和 "),s("code",[t._v("modCount")]),t._v("这两个变量入手分析，刚刚说了 "),s("code",[t._v("modCount")]),t._v(" 在 "),s("code",[t._v("AbstractList")]),t._v("类中定义，而 "),s("code",[t._v("expectedModCount")]),t._v("在"),s("code",[t._v("ArrayList")]),t._v(" 内部类中定义，所以 "),s("code",[t._v("modCount")]),t._v("是个共享变量而 "),s("code",[t._v("expectedModCount")]),t._v(" 是属于线程各自的。简单说，线程1更新了 "),s("code",[t._v("modCount")]),t._v("和属于自己的 "),s("code",[t._v("expectedModCount")]),t._v("，而在线程2看来只有 "),s("code",[t._v("modCount")]),t._v("更新了， "),s("code",[t._v("expectedModCount")]),t._v(" 并未更新，所 以会抛出 "),s("code",[t._v("ConcurrentModificationException")]),t._v("异常。")]),t._v(" "),s("h3",{attrs:{id:"fail-safe-安全失败"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fail-safe-安全失败"}},[t._v("#")]),t._v(" fail-safe(安全失败)")]),t._v(" "),s("p",[t._v("采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内 容，在拷贝的集合上进行遍历。所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所 以不会抛出"),s("code",[t._v("ConcurrentModificationException")]),t._v("异常。缺点是迭代器遍历的是开始遍历那一刻拿 到的集合拷贝，在遍历期间原集合发生了修改，迭代器是无法访问到修改后的内容。"),s("code",[t._v("java.util.concurrent")]),t._v(" 包下的容器都是安全失败，可以在多线程下并发使用。")]),t._v(" "),s("h2",{attrs:{id:"如何边遍历边移除-collection-中的元素"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何边遍历边移除-collection-中的元素"}},[t._v("#")]),t._v(" 如何边遍历边移除 Collection 中的元素")]),t._v(" "),s("p",[t._v("从上文“快速失败机制”可知在遍历集合时如果直接调用"),s("code",[t._v("remove()")]),t._v("方法会抛出 "),s("code",[t._v("ConcurrentModificationException")]),t._v("异常，所以使用迭代器中调用 "),s("code",[t._v("remove()")]),t._v("方法")]),t._v(" "),s("h2",{attrs:{id:"array-和-arraylist-有何区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#array-和-arraylist-有何区别"}},[t._v("#")]),t._v(" Array 和 ArrayList 有何区别")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("Array")]),t._v(" 可以包含基本类型和对象类型，"),s("code",[t._v("ArrayList")]),t._v("只能包含对象类型。")]),t._v(" "),s("li",[s("code",[t._v("Array")]),t._v("大小是固定的， "),s("code",[t._v("ArrayList")]),t._v("的大小是动态变化的。( "),s("code",[t._v("ArrayList")]),t._v(" 的扩容是个常见面试题)")]),t._v(" "),s("li",[t._v("相比于"),s("code",[t._v("Array")]),t._v(" ， "),s("code",[t._v("ArrayList")]),t._v("有着更多的内置方法，如 "),s("code",[t._v("addAll()")]),t._v(" ， "),s("code",[t._v("removeAll()")]),t._v("。 对于基本类型数据，")]),t._v(" "),s("li",[s("code",[t._v("ArrayList")]),t._v("使用自动装箱来减少编码工作量；而当处理固定大小的基本数据 类型的时候，这种方式相对比较慢，这时候应该使用 "),s("code",[t._v("Array")]),t._v(" 。")])]),t._v(" "),s("h2",{attrs:{id:"list集合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#list集合"}},[t._v("#")]),t._v(" List集合")]),t._v(" "),s("h3",{attrs:{id:"遍历一个-list-有哪些不同的方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#遍历一个-list-有哪些不同的方式"}},[t._v("#")]),t._v(" 遍历一个 List 有哪些不同的方式")]),t._v(" "),s("p",[t._v("先说一下常见的元素在内存中的存储方式，主要有两种：")]),t._v(" "),s("ol",[s("li",[t._v("顺序存储（Random Access）：相邻的数据元素在内存中的位置也是相邻的，可以根据元素的位置 （如 "),s("code",[t._v("ArrayList")]),t._v(" 中的下表）读取元素。")]),t._v(" "),s("li",[t._v("链式存储（Sequential Access）：每个数据元素包含它下一个元素的内存地址，在内存中不要求相 邻。例如"),s("code",[t._v("LinkedList")]),t._v(" 。")])]),t._v(" "),s("p",[t._v("主要的遍历方式主要有三种：")]),t._v(" "),s("ol",[s("li",[s("code",[t._v("for")]),t._v("循环遍历：遍历者自己在集合外部维护一个计数器，依次读取每一个位置的元素。")]),t._v(" "),s("li",[s("code",[t._v("Iterator")]),t._v(" 遍历：基于顺序存储集合的"),s("code",[t._v("Iterator")]),t._v(" 可以直接按位置访问数据。基于链式存储集合的 "),s("code",[t._v("Iterator")]),t._v(" ，需要保存当前遍历的位置，然后根据当前位置来向前或者向后移动指针。")]),t._v(" "),s("li",[s("code",[t._v("foreach")]),t._v(" 遍历： "),s("code",[t._v("foreach")]),t._v("内部也是采用了 "),s("code",[t._v("Iterator")]),t._v(" 的方式实现，但使用时不需要显示地声明"),s("code",[t._v("Iterator")]),t._v(" 。")])]),t._v(" "),s("p",[t._v("那么对于以上三种遍历方式应该如何选取呢")]),t._v(" "),s("p",[t._v("在Java集合框架中，提供了一个 "),s("code",[t._v("RandomAccess")]),t._v(" 接口，该接口没有方法，只是一个标记。通常用来标记 List 的实现是否支持 "),s("code",[t._v("RandomAccess")]),t._v(" 。所以在遍历时，可以先判断是否支持 "),s("code",[t._v("RandomAccess")]),t._v(" （ "),s("code",[t._v("list instanceof RandomAccess")]),t._v(" ），如果支持可用 "),s("code",[t._v("for")]),t._v(" 循环遍历，否则建议用 "),s("code",[t._v("Iterator")]),t._v(" 或 "),s("code",[t._v("foreach")]),t._v(" 遍历。")]),t._v(" "),s("h3",{attrs:{id:"arraylist的扩容机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#arraylist的扩容机制"}},[t._v("#")]),t._v(" ArrayList的扩容机制")]),t._v(" "),s("p",[t._v("先说下结论，一般面试时需要记住， ArrayList 的初始容量为10，扩容时对是旧的容量值加上旧 的容量数值进行右移一位（位运算，相当于除以2，位运算的效率更高），所以每次扩容都是旧的容量的1.5倍。")]),t._v(" "),s("p",[t._v("以JDK1.8为例说明")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("E")]),t._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//判断是否可以容纳e，若能，则直接添加在末尾；若不能，则进行扩容，然后再把e添加在末尾")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ensureCapacityInternal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("size "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Increments modCount!!")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//将e添加到数组末尾")]),t._v("\n    elementData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("size"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 每次在add()一个元素时，arraylist都需要对这个list的容量进行一个判断。通过ensureCapacityInternal()方法确保当前ArrayList维护的数组具有存储新元素的能力，经过处理之后将元素存储在数组elementData的尾部")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ensureCapacityInternal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" minCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ensureExplicitCapacity")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("calculateCapacity")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("elementData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" minCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("calculateCapacity")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" elementData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" minCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//如果传入的是个空数组则最小容量取默认容量与minCapacity之间的最大值")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("elementData "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" DEFAULTCAPACITY_EMPTY_ELEMENTDATA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Math")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("max")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("DEFAULT_CAPACITY"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" minCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" minCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    \n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ensureExplicitCapacity")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" minCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        modCount"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 若ArrayList已有的存储能力满足最低存储要求，则返回add直接添加元素；如果最低要求的存储能力>ArrayList已有的存储能力，这就表示ArrayList的存储能力不足，因此需要调用 grow();方法进行扩容")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("minCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" elementData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("grow")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("minCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("grow")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" minCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取elementData数组的内存空间长度")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" oldCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" elementData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 扩容至原来的1.5倍")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" newCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" oldCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("oldCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//校验容量是否够")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("newCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" minCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            newCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" minCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//若预设值大于默认的最大值，检查是否溢出")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("newCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" MAX_ARRAY_SIZE "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            newCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hugeCapacity")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("minCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 调用Arrays.copyOf方法将elementData数组指向新的内存空间")]),t._v("\n         "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//并将elementData的数据复制到新的内存空间")]),t._v("\n        elementData "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Arrays")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("copyOf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("elementData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" newCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"arraylist-和-linkedlist-的区别是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#arraylist-和-linkedlist-的区别是什么"}},[t._v("#")]),t._v(" ArrayList 和 LinkedList 的区别是什么")]),t._v(" "),s("ul",[s("li",[t._v("是否线程安全： "),s("code",[t._v("ArrayList")]),t._v(" 和"),s("code",[t._v("LinkedList")]),t._v("都是不保证线程安全的")]),t._v(" "),s("li",[t._v("底层实现： "),s("code",[t._v("ArrayList")]),t._v("的底层实现是数组， "),s("code",[t._v("LinkedList")]),t._v("的底层是双向链表。")]),t._v(" "),s("li",[t._v("内存占用： "),s("code",[t._v("ArrayList")]),t._v(" 会存在一定的空间浪费，因为每次扩容都是之前的1.5倍，而 "),s("code",[t._v("LinkedList")]),t._v(" 中的每个元素要存放直接后继和直接前驱以及数据，所以对于每个元素的存储都要比 "),s("code",[t._v("ArrayList")]),t._v(" 花费更多的空间。")]),t._v(" "),s("li",[t._v("应用场景："),s("code",[t._v("ArrayList")]),t._v("的底层数据结构是数组，所以在插入和删除元素时的时间复杂度都会收到 位置的影响，平均时间复杂度为o(n)，在读取元素的时候可以根据下标直接查找到元素，不受位置 的影响，平均时间复杂度为o(1)，所以 "),s("code",[t._v("ArrayList")]),t._v(" 更加"),s("strong",[t._v("适用于多读，少增删的场景")]),t._v("。 "),s("code",[t._v("LinkedList")]),t._v("的底层数据结构是双向链表，所以插入和删除元素不受位置的影响，平均时间复杂度为o(1)，如果是在指定位置插入则是o(n)，因为在插入之前需要先找到该位置，读取元素的平均时间复杂度为 o(n)。所以 "),s("code",[t._v("LinkedList")]),t._v(" "),s("strong",[t._v("更加适用于多增删，少读写的场景")]),t._v("。")])]),t._v(" "),s("h3",{attrs:{id:"arraylist-和-vector-的区别是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#arraylist-和-vector-的区别是什么"}},[t._v("#")]),t._v(" ArrayList 和 Vector 的区别是什么")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("相同点")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("都实现了 "),s("code",[t._v("List")]),t._v("接口")])]),t._v(" "),s("li",[s("p",[t._v("底层数据结构都是数组")])])])]),t._v(" "),s("li",[s("p",[t._v("不同点")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("线程安全： "),s("code",[t._v("Vector")]),t._v(" 使用了 Synchronized 来实现线程同步，所以是线程安全的，而 "),s("code",[t._v("ArrayList")]),t._v(" 是线程不安全的。")])]),t._v(" "),s("li",[s("p",[t._v("性能：由于"),s("code",[t._v("Vector")]),t._v("使用了 "),s("code",[t._v("Synchronized")]),t._v("进行加锁，所以性能不如 "),s("code",[t._v("ArrayList")])])]),t._v(" "),s("li",[s("p",[t._v("扩容： "),s("code",[t._v("ArrayList")]),t._v(" 和 "),s("code",[t._v("Vector")]),t._v("都会根据需要动态的调整容量，但是 "),s("code",[t._v("ArrayList")]),t._v(" 每次扩容为旧 容量的1.5倍，而 "),s("code",[t._v("Vector")]),t._v(" 每次扩容为旧容量的2倍。")])])])])]),t._v(" "),s("h3",{attrs:{id:"简述-arraylist、vector、linkedlist-的存储性能和特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#简述-arraylist、vector、linkedlist-的存储性能和特性"}},[t._v("#")]),t._v(" 简述 ArrayList、Vector、LinkedList 的存储性能和特性")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("ArrayList")]),t._v(" 底层数据结构为数组，对元素的读取速度快，而增删数据慢，线程不安全。")]),t._v(" "),s("li",[s("code",[t._v("LinkedList")]),t._v(" 底层为双向链表，对元素的增删数据快，读取慢，线程不安全。")]),t._v(" "),s("li",[s("code",[t._v("Vector")]),t._v(" 的底层数据结构为数组，用 "),s("code",[t._v("Synchronized")]),t._v(" 来保证线程安全，性能较差，但线程安全。")])]),t._v(" "),s("h2",{attrs:{id:"set集合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#set集合"}},[t._v("#")]),t._v(" Set集合")]),t._v(" "),s("h3",{attrs:{id:"hashset-的实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashset-的实现原理"}},[t._v("#")]),t._v(" HashSet 的实现原理")]),t._v(" "),s("p",[s("code",[t._v("HashSet")]),t._v("的底层是 "),s("code",[t._v("HashMap")]),t._v("，默认构造函数是构建一个初始容量为16，负载因子为0.75 的 "),s("code",[t._v("HashMap")]),t._v("。 "),s("code",[t._v("HashSet")]),t._v(" 的值存放于 "),s("code",[t._v("HashMap")]),t._v(" 的 key 上， "),s("code",[t._v("HashMap")]),t._v("的"),s("code",[t._v("value")]),t._v("统一为 "),s("code",[t._v("PRESENT")])]),t._v(" "),s("h3",{attrs:{id:"hashset如何检查重复"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashset如何检查重复"}},[t._v("#")]),t._v(" HashSet如何检查重复")]),t._v(" "),s("p",[s("code",[t._v("HashSet")]),t._v("的特点是存储元素时无序且唯一，在向 "),s("code",[t._v("HashSet")]),t._v("中添加对象时，首相会计算对象的"),s("code",[t._v("HashCode")]),t._v(" 值来确定对象的存储位置，如果该位置没有其他对象，直接将该对象添加到该位置；如果该存储位置有存储其他对象（新添加的对象和该存储位置的对象的 "),s("code",[t._v("HashCode")]),t._v("值相同），调用 "),s("code",[t._v("equals")]),t._v("方法判断两个对象是否相同，如果相同，则添加对象失败，如果不相同，则会将该对象重新散列到其他位置。")]),t._v(" "),s("h3",{attrs:{id:"hashset与hashmap的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashset与hashmap的区别"}},[t._v("#")]),t._v(" HashSet与HashMap的区别")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}},[t._v("HashMap")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("HashSet")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("实现了 Map 接口")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("实现了 Set 接口")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("存储键值对")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("存储对象")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("key 唯一， value 不唯一")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("存储对象唯一")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("HashMap 使用键（ Key ）计算 Hashcode")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("HashSet 使用成员对象来计算 hashcode 值")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("速度相对较快")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("速度相对较慢")])])])]),t._v(" "),s("h3",{attrs:{id:"hashset、linkedhashset-和-treeset-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashset、linkedhashset-和-treeset-的区别"}},[t._v("#")]),t._v(" HashSet、LinkedHashSet 和 TreeSet 的区别")]),t._v(" "),s("p",[s("code",[t._v("HashSet")]),t._v("是 Set 接口的主要实现类 ，"),s("code",[t._v("HashSet")]),t._v("的底层是 "),s("code",[t._v("HashMap")]),t._v("，线程不安全的，可以存储 null 值；")]),t._v(" "),s("p",[s("code",[t._v("LinkedHashSet")]),t._v(" 是 "),s("code",[t._v("HashSet")]),t._v("的子类，能够按照添加的顺序遍历；")]),t._v(" "),s("p",[s("code",[t._v("TreeSet")]),t._v("底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式可以自定义")]),t._v(" "),s("h2",{attrs:{id:"map集合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#map集合"}},[t._v("#")]),t._v(" Map集合")]),t._v(" "),s("h3",{attrs:{id:"hashmap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[t._v("#")]),t._v(" HashMap")]),t._v(" "),s("h5",{attrs:{id:"hashmap的底层实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的底层实现"}},[t._v("#")]),t._v(" HashMap的底层实现")]),t._v(" "),s("ul",[s("li",[t._v("JDK1.7的底层数据结构(数组+链表)")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209131438672.png",alt:"image-20220419151152529"}})]),t._v(" "),s("ul",[s("li",[t._v("JDK1.8的底层数据结构(数组+链表/红黑树)")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209131438735.png",alt:"image-20220419151221212"}})]),t._v(" "),s("ul",[s("li",[t._v("JDK1.7的Hash函数")])]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n h "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>>")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("12")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" h"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("ul",[s("li",[t._v("JDK1.8的Hash函数")])]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Onject")]),t._v(" key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hashCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("JDK1.8的函数经过了一次异或一次位运算一共两次扰动，而JDK1.7经过了四次位运算五次异或一共 九次扰动。这里简单解释下JDK1.8的hash函数，面试经常问这个，两次扰动分别是 "),s("code",[t._v("key.hashCode()")]),t._v("与 "),s("code",[t._v("key.hashCode()")]),t._v("右移16位进行异或。这样做的目的是，高16位不变，低16 位与高16位进行异或操作，进而减少碰撞的发生，高低Bit都参与到Hash的计算。如何不进行扰动处理，因为hash值有32位，直接对数组的长度求余，起作用只是hash值的几个低位。")]),t._v(" "),s("p",[s("strong",[t._v("HashMap在JDK1.7和JDK1.8中有哪些不同点")])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}}),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("JDK1.7")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("JDK1.8")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("JDK1.8的优势")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("底层结构")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("数组+链表")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("数组+链表/红 黑树(链表大于8)")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("避免单条链表过长而影响查询效 率，提高查询效率")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("hash值计算方式")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("9次扰动 = 4次位运算 + 5 次异或运算")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("2次扰动 = 1次 位运算 + 1次异 或运算")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("可以均匀地把之前的冲突的节点分散到新的桶（具体细节见下面扩容部分）")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("插入数据方式")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("头插法（先讲原位置的数 据移到后1位，再插入数据 到该位置）")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("尾插法（直接 插入到链表尾 部/红黑树）")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("解决多线程造成死循环地问题")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("扩容后存储位置的计算方式")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("重新进行hash计算")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("原位置或原位 置+旧容量")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("省去了重新计算hash值的时间")])])])]),t._v(" "),s("h5",{attrs:{id:"hashmap-的长度为什么是2的幂次方"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-的长度为什么是2的幂次方"}},[t._v("#")]),t._v(" HashMap 的长度为什么是2的幂次方")]),t._v(" "),s("p",[t._v("因为 "),s("code",[t._v("HashMap")]),t._v("是通过 "),s("code",[t._v("key")]),t._v("的"),s("code",[t._v("hash")]),t._v("值来确定存储的位置，但"),s("code",[t._v("Hash")]),t._v("值的范围是-2147483648到 2147483647，不可能建立一个这么大的数组来覆盖所有"),s("code",[t._v("hash")]),t._v("值。所以在计算完hash值后会对数组的长度进行取余操作，如果数组的长度是2的幂次方， "),s("code",[t._v("(length - 1)&hash")]),t._v(" 等同于 "),s("code",[t._v("hash%length")]),t._v("，可以用"),s("code",[t._v("(length - 1)&hash")]),t._v("这种位运算来代替%取余的操作进而提高性能。")]),t._v(" "),s("h5",{attrs:{id:"hashmap的put方法的具体流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的put方法的具体流程"}},[t._v("#")]),t._v(" HashMap的put方法的具体流程")]),t._v(" "),s("p",[t._v("简要流程如下：")]),t._v(" "),s("ol",[s("li",[t._v("首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；")]),t._v(" "),s("li",[t._v("如果数组是空的，则调用 resize 进行初始化；")]),t._v(" "),s("li",[t._v("如果没有哈希冲突直接放在对应的数组下标里；")]),t._v(" "),s("li",[t._v("如果冲突了，且 key 已经存在，就覆盖掉 value；")]),t._v(" "),s("li",[t._v("如果冲突后，发现该节点是红黑树，就将这个节点挂在树上；")]),t._v(" "),s("li",[t._v("如果冲突后是链表，判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；否则，链表插入键值对，若 key 存在，就覆盖掉 value。")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209131438764.jpeg",alt:"hashmap之put方法(JDK1.8)"}})]),t._v(" "),s("h5",{attrs:{id:"hashmap的扩容操作是怎么实现的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的扩容操作是怎么实现的"}},[t._v("#")]),t._v(" HashMap的扩容操作是怎么实现的")]),t._v(" "),s("ul",[s("li",[t._v("初始值为16，负载因子为0.75，阈值为负载因子*容量")]),t._v(" "),s("li",[s("code",[t._v("resize()")]),t._v("方法是在 hashmap 中的键值对大于阀值时或者初始化时，就调用 "),s("code",[t._v("resize()")]),t._v("方法进行扩容。")]),t._v(" "),s("li",[t._v("每次扩容，容量都是之前的两倍")]),t._v(" "),s("li",[t._v("扩容时有个判断"),s("code",[t._v("e.hash & oldCap")]),t._v(" 是否为零，也就是相当于"),s("code",[t._v("hash")]),t._v("值对数组长度的取余操作，若等 于0，则位置不变，若等于1，位置变为原位置加旧容量")])]),t._v(" "),s("p",[t._v("先来看下JDK1.7 的代码：")]),t._v(" "),s("div",{staticClass:"language-JAVA extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("resize")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" newCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//传入新的容量")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Entry")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" oldTable "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" table"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//引用扩容前的Entry数组")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" oldCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" oldTable"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("oldCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" MAXIMUM_CAPACITY"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//扩容前的数组大小如果已经达到最大(2^30)了")]),t._v("\n            threshold "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("MAX_VALUE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Entry")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" newTable "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Entry")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("newCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//初始化一个新的Entry数组")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("transfer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("newTable"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("                         "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//！！将数据转移到新的Entry数组里")]),t._v("\n        table "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" newTable"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("                           "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//HashMap的table属性引用新的Entry数组")]),t._v("\n        threshold "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("newCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" loadFactor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//修改阈值")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("transfer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Entry")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" newTable"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Entry")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" src "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" table"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("                   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//src引用了旧的Entry数组")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" newCapacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" newTable"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" src"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" j"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//遍历旧的Entry数组")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Entry")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" e "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" src"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//取得旧Entry数组的每个元素")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                src"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Entry")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" next "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("indexFor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("hash"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" newCapacity"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//！！重新计算每个元素在数组中的位置")]),t._v("\n                    e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" newTable"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//标记[1]")]),t._v("\n                    newTable"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//将元素放在数组上")]),t._v("\n                    e "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" next"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//访问下一个Entry链上的元素")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("newTable[i] 的引用赋给了 e.next ，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到 Entry 链的尾部(如果发生了 hash 冲突的话）。")]),t._v(" "),s("h5",{attrs:{id:"hashmap默认加载因子为什么选择0-75"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap默认加载因子为什么选择0-75"}},[t._v("#")]),t._v(" HashMap默认加载因子为什么选择0.75")]),t._v(" "),s("p",[t._v("这个主要是考虑空间利用率和查询成本的一个折中。如果加载因子过高，空间利用率提高，但是会使得哈希冲突的概率增加；如果加载因子过低，会频繁扩容，哈希冲突概率降低，但是会使得空间利用率变 低。")]),t._v(" "),s("ul",[s("li",[t._v("如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值 。")]),t._v(" "),s("li",[t._v("相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。")])]),t._v(" "),s("h5",{attrs:{id:"为什么要将链表中转红黑树的阈值设为8？为什么不一开始直接使用红黑树？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么要将链表中转红黑树的阈值设为8？为什么不一开始直接使用红黑树？"}},[t._v("#")]),t._v(" 为什么要将链表中转红黑树的阈值设为8？为什么不一开始直接使用红黑树？")]),t._v(" "),s("p",[t._v("因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。")]),t._v(" "),s("h5",{attrs:{id:"hashmap是怎么解决哈希冲突的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap是怎么解决哈希冲突的"}},[t._v("#")]),t._v(" HashMap是怎么解决哈希冲突的")]),t._v(" "),s("p",[t._v("哈希冲突："),s("code",[t._v("hashMap")]),t._v(" 在存储元素时会先计算 key 的hash值来确定存储位置，因为 "),s("code",[t._v("key")]),t._v(" 的"),s("code",[t._v("hash")]),t._v("值计算最 后有个对数组长度取余的操作，所以即使不同的"),s("code",[t._v("key")]),t._v(" 也可能计算出相同的"),s("code",[t._v("hash")]),t._v("值，这样就引起了"),s("code",[t._v("hash")]),t._v("冲突。"),s("code",[t._v("hashMap")]),t._v(" 的底层结构中的链表/红黑树就是用来解决这个问题的。")]),t._v(" "),s("ul",[s("li",[t._v("拉链法")])]),t._v(" "),s("p",[s("code",[t._v("HasMap")]),t._v("中的数据结构为数组+链表/红黑树，当不同的"),s("code",[t._v("key")]),t._v(" 计算出的"),s("code",[t._v("hash")]),t._v("值相同时，就用链表的形 式将"),s("code",[t._v("Node")]),t._v("结点（冲突的 "),s("code",[t._v("key")]),t._v(" 及"),s("code",[t._v("key")]),t._v("对应的 "),s("code",[t._v("value")]),t._v("）挂在数组后面。")]),t._v(" "),s("ul",[s("li",[t._v("hash函数")])]),t._v(" "),s("p",[s("code",[t._v("key")]),t._v("的"),s("code",[t._v("hash")]),t._v("值经过两次扰动，"),s("code",[t._v("key")]),t._v("的 "),s("code",[t._v("hashCode")]),t._v("值与"),s("code",[t._v("key")]),t._v(" 的 "),s("code",[t._v("hashCode")]),t._v(" 值的右移16位进行异或，然 后对数组的长度取余（实际为了提高性能用的是位运算，但目的和取余一样），这样做可以让"),s("code",[t._v("hashCode")]),t._v(" 取值出的高位也参与运算，进一步降低"),s("code",[t._v("hash")]),t._v("冲突的概率，使得数据分布更平均。")]),t._v(" "),s("ul",[s("li",[t._v("红黑树")])]),t._v(" "),s("p",[t._v("在拉链法中，如果"),s("code",[t._v("hash")]),t._v("冲突特别严重，则会导致数组上挂的链表长度过长，性能变差，因此在链表长度大于8时，将链表转化为红黑树，可以提高遍历链表的速度")]),t._v(" "),s("h5",{attrs:{id:"为什么hashmap中string、integer这样的包装类适合作为key"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么hashmap中string、integer这样的包装类适合作为key"}},[t._v("#")]),t._v(" 为什么HashMap中String、Integer这样的包装类适合作为Key")]),t._v(" "),s("ul",[s("li",[t._v("这些包装类都是"),s("code",[t._v("final")]),t._v(" 修饰，是不可变性的， 保证了"),s("code",[t._v("key")]),t._v("的不可更改性，不会出现放入和获取时哈希值不同的情况。")]),t._v(" "),s("li",[t._v("它们内部已经重写过"),s("code",[t._v("hashcode()")]),t._v(", "),s("code",[t._v("equal()")]),t._v("等方法")])]),t._v(" "),s("h5",{attrs:{id:"hashmap多线程导致死循环问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap多线程导致死循环问题"}},[t._v("#")]),t._v(" HashMap多线程导致死循环问题")]),t._v(" "),s("p",[t._v("由于JDK1.7的 "),s("code",[t._v("hashMap")]),t._v("遇到hash冲突采用的是头插法，在多线程情况下会存在死循环问题，但 JDK1.8已经改成了尾插法，不存在这个问题了。但需要注意的是JDK1.8中的 HashMap 仍然是不安全的，在多线程情况下使用仍然会出现线程安全问题。")]),t._v(" "),s("h5",{attrs:{id:"hashmap为什么线程不安全"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap为什么线程不安全"}},[t._v("#")]),t._v(" HashMap为什么线程不安全")]),t._v(" "),s("ul",[s("li",[t._v("多线程下扩容死循环。JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。")]),t._v(" "),s("li",[t._v("多线程的put可能导致元素的丢失。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和 JDK 1.8 中都存在。")]),t._v(" "),s("li",[t._v("put和get并发时，可能导致get为null。线程1执行put时，因为元素个数超出threshold而导致rehash，线程2此时执行get，有可能导致这个问题。此问题在JDK 1.7和 JDK 1.8 中都存在。")])]),t._v(" "),s("h5",{attrs:{id:"hashmap和hashtable的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap和hashtable的区别"}},[t._v("#")]),t._v(" HashMap和HashTable的区别")]),t._v(" "),s("p",[t._v("HashMap和Hashtable都实现了Map接口。")]),t._v(" "),s("ol",[s("li",[s("code",[t._v("HashMap")]),t._v("可以接受为"),s("code",[t._v("null")]),t._v("的"),s("code",[t._v("key")]),t._v("和"),s("code",[t._v("value")]),t._v("，"),s("code",[t._v("key")]),t._v("为``null`键值对放在下标为0的头结点的链表中，而 Hashtable则不行。")]),t._v(" "),s("li",[s("code",[t._v("HashMap")]),t._v("是非线程安全的，"),s("code",[t._v("HashTable")]),t._v("是线程安全的。Jdk1.5提供"),s("code",[t._v("ConcurrentHashMap")]),t._v("，它是 "),s("code",[t._v("HashTable")]),t._v("的替代。")]),t._v(" "),s("li",[s("code",[t._v("Hashtable")]),t._v("很多方法是同步方法，在单线程环境下它比"),s("code",[t._v("HashMap")]),t._v("要慢。")]),t._v(" "),s("li",[t._v("哈希值的使用不同，"),s("code",[t._v("HashTable")]),t._v("直接使用对象的"),s("code",[t._v("hashCode")]),t._v("。而"),s("code",[t._v("HashMap")]),t._v("重新计算"),s("code",[t._v("hash")]),t._v("值。")])]),t._v(" "),s("h4",{attrs:{id:"concurrenthashmap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap"}},[t._v("#")]),t._v(" ConcurrentHashMap")]),t._v(" "),s("p",[t._v("https://blog.csdn.net/qq_29051413/article/details/107869427")]),t._v(" "),s("p",[t._v("https://chenhongliang.blog.csdn.net/article/details/108844926?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-108844926-blog-126633921.topnsimilarv1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-108844926-blog-126633921.topnsimilarv1&utm_relevant_index=1")]),t._v(" "),s("h5",{attrs:{id:"concurrenthashmap-底层具体实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-底层具体实现"}},[t._v("#")]),t._v(" ConcurrentHashMap 底层具体实现")]),t._v(" "),s("ul",[s("li",[t._v("JDK1.7")])]),t._v(" "),s("p",[t._v("在JDK1.7中， "),s("code",[t._v("ConcurrentHashMap")]),t._v(" 采用"),s("code",[t._v("Segment")]),t._v("数组 + "),s("code",[t._v("HashEntry")]),t._v(" 数组的方式进行实现。"),s("code",[t._v("Segment")]),t._v("实现了"),s("code",[t._v("ReentrantLock")]),t._v("，所以 "),s("code",[t._v("Segment")]),t._v("有锁的性质， "),s("code",[t._v("HashEntry")]),t._v("用于存储键值对。一 个"),s("code",[t._v("ConcurrentHashMap")]),t._v("包含着一个 "),s("code",[t._v("Segment")]),t._v(" 数组，一个"),s("code",[t._v("Segment")]),t._v("包含着一个"),s("code",[t._v("HashEntry")]),t._v("数组，"),s("code",[t._v("HashEntry")]),t._v("是一个链表结构，如果要获取 "),s("code",[t._v("HashEntry")]),t._v("中的元素，要先获得 "),s("code",[t._v("Segment")]),t._v(" 的锁。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209131438807.png",alt:"img"}})]),t._v(" "),s("ul",[s("li",[s("p",[t._v('Segment数组的长度是16，初始化后不可扩容，每个Segment[i]内部的"HashTable"可以扩容。初始化时只初始化了Segment[0]槽，其他槽在插入第一个值时进行初始化。')])]),t._v(" "),s("li",[s("p",[t._v("Segment[i]的默认大小是2，负载因子是0.75。所以初始阈值是1.5，即当Segment[i]中插入第二个元素时，会发生扩容。")])]),t._v(" "),s("li",[s("p",[t._v("JDK1.8")])])]),t._v(" "),s("p",[t._v("在数据结构上， JDK1.8 中的ConcurrentHashMap 选择了与 HashMap 相同的"),s("strong",[t._v("数组+链表+红黑树")]),t._v("结构；在锁的实现上，抛弃了原有的"),s("code",[t._v("Segment")]),t._v("分段锁，采用"),s("code",[t._v("CAS + synchronized")]),t._v("实现更加低粒度的锁。")]),t._v(" "),s("p",[t._v("锁的级别控制在了更细粒度的哈希桶元素级别，也就是说只需要锁住这个链表头结点（红黑树的根节点），就不会影响其他的哈希桶元素的读写，大大提高了并发度。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209131438757.png",alt:"img"}})]),t._v(" "),s("h5",{attrs:{id:"concurrenthashmap-的-put-方法执行逻辑是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-的-put-方法执行逻辑是什么？"}},[t._v("#")]),t._v(" ConcurrentHashMap 的 put 方法执行逻辑是什么？")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("JDK1.7")])])]),t._v(" "),s("p",[t._v("首先，会尝试获取锁，如果获取失败，利用自旋获取锁；如果自旋重试的次数超过 64 次，则改为阻塞获取锁")]),t._v(" "),s("p",[t._v("获取到锁后：")]),t._v(" "),s("ol",[s("li",[t._v("将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。")]),t._v(" "),s("li",[t._v("遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。")]),t._v(" "),s("li",[t._v("不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。")]),t._v(" "),s("li",[t._v("释放 Segment 的锁。")])]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("JDK1.8")])])]),t._v(" "),s("ol",[s("li",[t._v("根据 key 计算出 hash值。")]),t._v(" "),s("li",[t._v("判断是否需要进行初始化。")]),t._v(" "),s("li",[t._v("定位到 Node，拿到首节点 f，判断首节点 f：\n"),s("ul",[s("li",[t._v("如果为 null ，则通过cas的方式尝试添加。")]),t._v(" "),s("li",[t._v("如果为 "),s("code",[t._v("f.hash = MOVED = -1")]),t._v(" ，说明其他线程在扩容，参与一起扩容。")]),t._v(" "),s("li",[t._v("如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入。")])])]),t._v(" "),s("li",[t._v("当在链表长度达到8的时候，数组扩容或者将链表转换为红黑树。")])]),t._v(" "),s("h5",{attrs:{id:"concurrenthashmap-的-get-方法是否要加锁，为什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-的-get-方法是否要加锁，为什么？"}},[t._v("#")]),t._v(" ConcurrentHashMap 的 get 方法是否要加锁，为什么？")]),t._v(" "),s("p",[t._v("get 方法不需要加锁。因为 Node 的元素 val 和指针 next 是用 volatile 修饰的，在多线程环境下线程A修改结点的val或者新增节点的时候是对线程B可见的。")]),t._v(" "),s("p",[t._v("这也是它比其他并发集合比如 Hashtable、用 Collections.synchronizedMap()包装的 HashMap 安全效率高的原因之一。")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Map")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Entry")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" hash"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("K")]),t._v(" key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//可以看到这些都用了volatile修饰")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("V")]),t._v(" val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" next"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h5",{attrs:{id:"concurrenthashmap-不支持-key-或者-value-为-null-的原因？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-不支持-key-或者-value-为-null-的原因？"}},[t._v("#")]),t._v(" ConcurrentHashMap 不支持 key 或者 value 为 null 的原因？")]),t._v(" "),s("p",[t._v("我们先来说value 为什么不能为 null ，因为"),s("code",[t._v("ConcurrentHashMap")]),t._v("是用于多线程的 ，如果"),s("code",[t._v("map.get(key)")]),t._v("得到了 null ，无法判断，是映射的value是 null ，还是没有找到对应的key而为 null ，这就有了二义性。")]),t._v(" "),s("p",[t._v("而用于单线程状态的"),s("code",[t._v("HashMap")]),t._v("却可以用"),s("code",[t._v("containsKey(key)")]),t._v(" 去判断到底是否包含了这个 null 。")]),t._v(" "),s("p",[t._v("我们用"),s("strong",[t._v("反证法")]),t._v("来推理：")]),t._v(" "),s("p",[t._v("假设ConcurrentHashMap 允许存放值为 null 的value，这时有A、B两个线程，线程A调用ConcurrentHashMap .get(key)方法，返回为 null ，我们不知道这个 null 是没有映射的 null ，还是存的值就是 null 。")]),t._v(" "),s("p",[t._v("假设此时，返回为 null 的真实情况是没有找到对应的key。那么，我们可以用ConcurrentHashMap .containsKey(key)来验证我们的假设是否成立，我们期望的结果是返回false。")]),t._v(" "),s("p",[t._v("但是在我们调用ConcurrentHashMap .get(key)方法之后，containsKey方法之前，线程B执行了ConcurrentHashMap .put(key, null )的操作。那么我们调用containsKey方法返回的就是true了，这就与我们的假设的真实情况不符合了，这就有了二义性。")]),t._v(" "),s("h5",{attrs:{id:"concurrenthashmap-迭代器是强一致性还是弱一致性？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-迭代器是强一致性还是弱一致性？"}},[t._v("#")]),t._v(" ConcurrentHashMap 迭代器是强一致性还是弱一致性？")]),t._v(" "),s("p",[t._v("与HashMap不同的是， ConcurrentHashMap 迭代器是弱一致性。 这里解释一下弱一致性是什么意思，当 ConcurrentHashMap 的迭代器创建后，会遍历哈希表中的元 素，在遍历的过程中，哈希表中的元素可能发生变化，如果这部分变化发生在已经遍历过的地方，迭代器则不会反映出来，如果这部分变化发生在未遍历过的地方，迭代器则会反映出来。换种说法就是 put() 方法将一个元素加入到底层数据结构后， get() 可能在某段时间内还看不到这个元素。 这样的设计主要是为 ConcurrenthashMap 的性能考虑，如果想做到强一致性，就要到处加锁，性能会下降很多。所以 ConcurrentHashMap 是支持在迭代过程中，向map中添加元素的，而HashMap这样操作则会抛出异常。")]),t._v(" "),s("h5",{attrs:{id:"concurrenthashmap结构中变量使用volatile和final修饰有什么作用？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap结构中变量使用volatile和final修饰有什么作用？"}},[t._v("#")]),t._v(" ConcurrentHashMap结构中变量使用volatile和final修饰有什么作用？")]),t._v(" "),s("p",[s("code",[t._v("final")]),t._v("修饰变量可以保证变量不需要同步就可以被访问和共享，"),s("code",[t._v("volatile")]),t._v("可以保证内存的可见性， 配合CAS操作可以在不加锁的前提支持并发")]),t._v(" "),s("h5",{attrs:{id:"concurrenthashmap-的key，value是否可以为null？为什么？-hashmap中的key、value是否可以为null？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-的key，value是否可以为null？为什么？-hashmap中的key、value是否可以为null？"}},[t._v("#")]),t._v(" ConCurrentHashMap 的key，value是否可以为null？为什么？ HashMap中的key、value是否可以为null？")]),t._v(" "),s("p",[s("code",[t._v("ConCurrentHashMap")]),t._v(" 中的"),s("code",[t._v("key")]),t._v("和"),s("code",[t._v("value")]),t._v("为 "),s("code",[t._v("null")]),t._v("会出现空指针异常，而 "),s("code",[t._v("HashMap")]),t._v("中的 "),s("code",[t._v("key")]),t._v(" 和 "),s("code",[t._v("value")]),t._v("值 是可以为 "),s("code",[t._v("null")]),t._v(" 的。 原因如下： "),s("code",[t._v("ConCurrentHashMap")]),t._v(" 是在多线程场景下使用的，如果"),s("code",[t._v("ConcurrentHashMap.get(key)")]),t._v("的值为 "),s("code",[t._v("null")]),t._v(" ，那么无法判断到底是"),s("code",[t._v("key")]),t._v(" 对应的 "),s("code",[t._v("value")]),t._v("的值为 "),s("code",[t._v("null")]),t._v(" 还是不存在对应的 "),s("code",[t._v("key")]),t._v(" 值。而在单线程场景下的 "),s("code",[t._v("HashMap")]),t._v(" 中，可以使用 "),s("code",[t._v("containsKey(key)")]),t._v("来判断到底是不存在这个 "),s("code",[t._v("key")]),t._v(" 还是"),s("code",[t._v("key")]),t._v("对应的 "),s("code",[t._v("value")]),t._v(" 的值为 "),s("code",[t._v("null")]),t._v(" 。在多线程的情况下使用 "),s("code",[t._v("containsKey(key)")]),t._v("来做这个判断是存在问题的，因为在 "),s("code",[t._v("containsKey(key)")]),t._v(" 和 "),s("code",[t._v("ConcurrentHashMap.get(key)")]),t._v(" 两次调用的过程中， "),s("code",[t._v("key")]),t._v("的值已经发生了改变。")]),t._v(" "),s("h3",{attrs:{id:"treemap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#treemap"}},[t._v("#")]),t._v(" TreeMap")]),t._v(" "),s("p",[t._v("TreeMap是一个能比较元素大小的Map集合，会对传入的key进行了大小排序。可以使用元素的自然顺序，也可以使用集合中自定义的比较器来进行排序。")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeMap")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AbstractMap")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("NavigableMap")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("K")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("V")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Cloneable")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" java"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("io"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Serializable")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("TreeMap的继承结构：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209131438341.png",alt:"image-20220419191324363"}})]),t._v(" "),s("p",[s("strong",[t._v("TreeMap的特点：")])]),t._v(" "),s("ol",[s("li",[s("code",[t._v("TreeMap")]),t._v("是有序的"),s("code",[t._v("key-value")]),t._v("集合，通过红黑树实现。根据键的自然顺序进行排序或根据提供的 "),s("code",[t._v("Comparator")]),t._v("进行排序。")]),t._v(" "),s("li",[s("code",[t._v("TreeMap")]),t._v("继承了"),s("code",[t._v("AbstractMap")]),t._v("，实现了"),s("code",[t._v("NavigableMap")]),t._v("接口，支持一系列的导航方法，给定具体搜 索目标，可以返回最接近的匹配项。如"),s("code",[t._v("floorEntry()")]),t._v("、"),s("code",[t._v("ceilingEntry()")]),t._v("分别返回小于等于、大于等于给定键关联的Map.Entry()对象，不存在则返回"),s("code",[t._v("null")]),t._v("。"),s("code",[t._v("lowerKey()")]),t._v("、"),s("code",[t._v("floorKey")]),t._v("、"),s("code",[t._v("ceilingKey")]),t._v("、 "),s("code",[t._v("higherKey()")]),t._v("只返回关联的"),s("code",[t._v("key")]),t._v("。")])]),t._v(" "),s("h2",{attrs:{id:"hashtable"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashtable"}},[t._v("#")]),t._v(" HashTable")]),t._v(" "),s("h3",{attrs:{id:"hashtable底层实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashtable底层实现"}},[t._v("#")]),t._v(" HashTable底层实现")]),t._v(" "),s("p",[s("code",[t._v("HashTable")]),t._v(" 的底层数据结构是数组+链表，链表主要是为了解决哈希冲突，并且整个数组都是 "),s("code",[t._v("synchronized")]),t._v("修饰的，所以 "),s("code",[t._v("HashTable")]),t._v("是线程安全的，但锁的粒度太大，锁的竞争非常激烈，效率很低。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://guli-file-fxy.oss-cn-shanghai.aliyuncs.com/img/202209131438533.png",alt:"image-20220419184205694"}})]),t._v(" "),s("h2",{attrs:{id:"hashmap、concurrenthashmap及hashtable-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap、concurrenthashmap及hashtable-的区别"}},[t._v("#")]),t._v(" HashMap、ConcurrentHashMap及Hashtable 的区别")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}}),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("HashMap(JDK1.8")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("ConcurrentHashMap(JDK1.8)")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("Hashtable")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("底层实现")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("数组+链表/红黑树")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("数组+链表/红黑树")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("数组+链表")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("线程安全")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("不安全")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("安全( Synchronized 修饰Node 节点")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("安全 ( Synchronized 修 饰整个表)")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("效率")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("高")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("较高")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("低")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("扩容")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("初始16，每次扩容成 2n")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("初始16，每次扩容成2n")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("初始11，每次扩容 成2n+1")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("是否支持 Null key和 Null Value")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("可以有一个Null key，Null Value多个")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("不支持")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("不支持")])])])])])}),[],!1,null,null,null);a.default=e.exports}}]);